var documenterSearchIndex = {"docs":
[{"location":"usage/#High-level-docstrings","page":"Usage","title":"High-level docstrings","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"This section lists the main interfaces for interacting with codes that use Jutul as their foundation.","category":"page"},{"location":"usage/#Setting-up-models","page":"Usage","title":"Setting up models","text":"","category":"section"},{"location":"usage/#Jutul.SimulationModel","page":"Usage","title":"Jutul.SimulationModel","text":"SimulationModel(domain, system; <kwarg>)\n\nInstantiate a model for a given system discretized on the domain.\n\n\n\n\n\nSimulationModel(g::JutulMesh, system; discretization = nothing, kwarg...)\n\nType that defines a simulation model - everything needed to solve the discrete equations.\n\nThe minimal setup requires a JutulMesh that defines topology together with a JutulSystem that imposes physical laws.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.MultiModel","page":"Usage","title":"Jutul.MultiModel","text":"MultiModel(models)\nMultiModel(models, :SomeLabel)\n\nA model variant that is made up of many named submodels, each a fully realized SimulationModel.\n\nmodels should be a NamedTuple or Dict{Symbol, JutulModel}.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Model-API","page":"Usage","title":"Model API","text":"","category":"section"},{"location":"usage/#Getters","page":"Usage","title":"Getters","text":"","category":"section"},{"location":"usage/#Jutul.get_secondary_variables","page":"Usage","title":"Jutul.get_secondary_variables","text":"get_secondary_variables(model::SimulationModel)\n\nGet the secondary variable definitions (as OrderedDict) for a given model.\n\nSecondary variables are variables that can be computed from the primary variables together with the parameters.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.get_primary_variables","page":"Usage","title":"Jutul.get_primary_variables","text":"get_primary_variables(model::SimulationModel)\n\nGet the primary variable definitions (as OrderedDict) for a given model.\n\nPrimary variables are sometimes referred to as solution variables or primary unknowns. The set of primary variables completely determines the state of the system together with the parameters.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.get_parameters","page":"Usage","title":"Jutul.get_parameters","text":"get_parameters(model::SimulationModel)\n\nGet the parameter definitions (as OrderedDict) for a given model.\n\nParameters are defined as static values in a forward simulation that combine with the primary variables to compute secondary variables and model equations.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.get_variables","page":"Usage","title":"Jutul.get_variables","text":"get_variables(model::SimulationModel)\n\nGet all variable definitions (as OrderedDict) for a given model.\n\nThis is the union of get_secondary_variables and get_primary_variables.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"Setters","category":"page"},{"location":"usage/#Jutul.set_secondary_variables!","page":"Usage","title":"Jutul.set_secondary_variables!","text":"set_secondary_variables!(model, varname = vardef)\nset_secondary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a secondary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.set_primary_variables!","page":"Usage","title":"Jutul.set_primary_variables!","text":"set_primary_variables!(model, varname = vardef)\nset_primary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a primary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.set_parameters!","page":"Usage","title":"Jutul.set_parameters!","text":"set_parameters!(model, parname = pardef)\n\nSet a parameter with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"Various","category":"page"},{"location":"usage/#Jutul.number_of_degrees_of_freedom","page":"Usage","title":"Jutul.number_of_degrees_of_freedom","text":"Total number of degrees of freedom for a model, over all primary variables and all entities.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.number_of_values","page":"Usage","title":"Jutul.number_of_values","text":"Total number of values for a model, for a given type of variables over all entities\n\n\n\n\n\n","category":"function"},{"location":"usage/#Systems-and-domains","page":"Usage","title":"Systems and domains","text":"","category":"section"},{"location":"usage/#Jutul.JutulSystem","page":"Usage","title":"Jutul.JutulSystem","text":"Abstract type for the physical system to be solved.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JutulContext","page":"Usage","title":"Jutul.JutulContext","text":"Abstract type for the context Jutul should execute in (matrix formats, memory allocation, etc.)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JutulDomain","page":"Usage","title":"Jutul.JutulDomain","text":"Abstract type for domains where equations can be defined\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.DataDomain","page":"Usage","title":"Jutul.DataDomain","text":"DataDomain(domain::JutulDomain; property1 = p1, property2 = p2, ...)\n\nA wrapper around a domain that allows for storing of entity-associated data.\n\nExample:\n\n# Grid with 6 cells and 7 interior faces\ng = CartesianMesh((2, 3))\nd = DataDomain(g)\nd[:cell_vec] = rand(6) #ok, same as:\nd[:cell_vec, Cells()] = rand(6) #ok\nd[:cell_vec, Faces()] = rand(6) #not ok!\nd[:face_vec, Faces()] = rand(7) #ok!\n# Can also add general arrays if last dimension == entity dimension\nd[:cell_vec, Cells()] = rand(10, 3, 6) #ok\n# Can add general data too, but needs to be specified\nd[:not_on_face_or_cell, nothing] = rand(3) # also ok\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.DiscretizedDomain","page":"Usage","title":"Jutul.DiscretizedDomain","text":"DiscretizedDomain(domain, disc = nothing)\n\nA type for a discretized domain of some other domain or mesh. May contain one or more discretizations as-needed to write equations.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JutulDiscretization","page":"Usage","title":"Jutul.JutulDiscretization","text":"Abstract type for a Jutul discretization\n\n\n\n\n\n","category":"type"},{"location":"usage/#Set-up-of-system","page":"Usage","title":"Set up of system","text":"","category":"section"},{"location":"usage/#Jutul.setup_state","page":"Usage","title":"Jutul.setup_state","text":"setup_state(model::JutulModel, name1 = value1, name2 = value2)\n\nSet up a state for a given model with values for the primary variables defined in the model. Normally all primary variables must be initialized in this way.\n\nArguments\n\nname=value: The name of the primary variable together with the value(s) used to initialize the primary variable.\n\nA scalar (or short vector of the right size for VectorVariables) will be repeated over the entire domain, while a vector (or matrix for VectorVariables) with length (number of columns for VectorVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\nNote: You likely want to overload [setup_state!]@ref for a custom model instead of setup_state\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_parameters","page":"Usage","title":"Jutul.setup_parameters","text":"setup_parameters(model::JutulModel; name = value)\n\nSet up a parameter storage for a given model with values for the parameter defined in the model.\n\nArguments\n\nname=value: The name of the parameter together with the value(s) of the parameter.\n\nA scalar (or short vector of the right size for VectorVariables) will be repeated over the entire domain, while a vector (or matrix for VectorVariables) with length (number of columns for VectorVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_state_and_parameters","page":"Usage","title":"Jutul.setup_state_and_parameters","text":"state, prm = setup_state_and_parameters(model, init)\n\nSimultaneously set up state and parameters from a single init file (typically a Dict containing values that might either be initial values or parameters)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_forces","page":"Usage","title":"Jutul.setup_forces","text":"setup_forces(model::JutulModel; force_name = force_value)\n\nSet up forces for a given model. Keyword arguments varies depending on what the model supports.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulator-interfaces","page":"Usage","title":"Simulator interfaces","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Used to run simulations once a model has been set up.","category":"page"},{"location":"usage/#Jutul.simulate","page":"Usage","title":"Jutul.simulate","text":"simulate(state0, model, timesteps, parameters = setup_parameters(model))\nsimulate(state0, model, timesteps, info_level = 3)\nsimulate(state0, model, timesteps; <keyword arguments>)\n\nSimulate a set of timesteps with model for the given initial state0 and optionally specific parameters. Additional keyword arguments are passed onto simulator_config and simulate!. This interface is primarily for convenience, as all storage for the simulator is allocated upon use and discared upon return. If you want to perform multiple simulations with the same model it is advised to instead instantiate Simulator  and combine it with simulate!.\n\nArguments\n\nstate0::Dict: initial state, typically created using setup_state for the model in use.\nmodel::JutulModel: model that describes the discretized system to solve, for example SimulationModel or MultiModel.\ntimesteps::AbstractVector: Vector of desired report steps. The simulator will perform time integration until sum(timesteps)  is reached, providing outputs at the end of each report step.\nparameters=setup_parameters(model): Optional overrides the default parameters for the model.\nforces=nothing: Either nothing (for no forces), a single set of forces from setup_forces(model) or a Vector of such forces with equal length to timesteps.\nrestart=nothing: If an integer is provided, the simulation will attempt to restart from that step. Requires that output_path is provided here or in the config.\nconfig=simulator_config(model): Configuration Dict that holds many fine grained settings for output, linear solver, time-steps, outputs etc.\n\nAdditional arguments are passed onto simulator_config.\n\nSee also simulate!, Simulator, SimulationModel, simulator_config.\n\n\n\n\n\nsimulate(state0, sim::JutulSimulator, timesteps::AbstractVector; parameters = nothing, kwarg...)\n\nSimulate a set of timesteps with simulator for the given initial state0 and optionally specific parameters.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.simulate!","page":"Usage","title":"Jutul.simulate!","text":"simulate!(sim::JutulSimulator, timesteps::AbstractVector;\n    forces = nothing,\n    config = nothing,\n    initialize = true,\n    restart = nothing,\n    state0 = nothing,\n    parameters = nothing,\n    kwarg...\n)\n\nNon-allocating (or perhaps less allocating) version of simulate!.\n\nArguments\n\ninitialize=true: Perform internal updates as if this is the first time \n\nSee also simulate for additional supported input arguments.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.solve_timestep!","page":"Usage","title":"Jutul.solve_timestep!","text":"solve_timestep!(sim, dT, forces, max_its, config; <keyword arguments>)\n\nInternal function for solving a single time-step with fixed driving forces.\n\nArguments\n\nsim: Simulator instance.\ndT: time-step to be solved\nforces: Driving forces for the time-step\nmax_its: Maximum number of steps/Newton iterations.\nconfig: Configuration for solver (typically output from simulator_config).\n\nNote: This function is exported for fine-grained simulation workflows. The general simulate interface is both easier to use and performs additional validation.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"Configure a simulator:","category":"page"},{"location":"usage/#Jutul.Simulator","page":"Usage","title":"Jutul.Simulator","text":"Simulator(model; <kwarg>)\n\nSet up a simulator object for a model that can be used by simulate!. To avoid manually instantiating the simulator, the non-mutating simulate interface can be used instead.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.simulator_config","page":"Usage","title":"Jutul.simulator_config","text":"simulator_config(sim; info_level = 3, linear_solver = GenericKrylov())\n\nSet up a simulator configuration object that can be passed onto simulate!.\n\nThere are many options available to configure a given simulator. The best way to get an overview of these possible configuration options is to instatiate the config without any arguments and inspecting the resulting table by calling simulator_config(sim) in the REPL.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.JutulConfig","page":"Usage","title":"Jutul.JutulConfig","text":"JutulConfig(name = nothing)\n\nA configuration object that acts like a Dict{Symbol,Any} but contains additional data to limit the valid keys and values to those added by add_option!\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.add_option!","page":"Usage","title":"Jutul.add_option!","text":"add_option!(opts::JutulConfig, :my_cool_option, 3, \"My option has this brief description\")\n\nAdd an option to existing JutulConfig structure. Additional currently undocumented keyword arguments can be used to restrict valid types and values.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sensitivities,-adjoints-and-optimization","page":"Usage","title":"Sensitivities, adjoints and optimization","text":"","category":"section"},{"location":"usage/#Jutul.solve_adjoint_sensitivities","page":"Usage","title":"Jutul.solve_adjoint_sensitivities","text":"solve_adjoint_sensitivities(model, states, reports_or_timesteps, G; extra_timing = false, state0 = setup_state(model), forces = setup_forces(model), raw_output = false, kwarg...)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nThe objective function is at the moment assumed to be a sum over all states on the form: obj = Σₙ G(model, state, dt_n, n, forces_for_step_n)\n\nSolves the adjoint equations: For model equations F the gradient with respect to parameters p is     ∇ₚG = Σₙ (∂Fₙ / ∂p)ᵀ λₙ where n ∈ [1, N]. Given Lagrange multipliers λₙ from the adjoint equations     (∂Fₙ / ∂xₙ)ᵀ λₙ = - (∂J / ∂xₙ)ᵀ - (∂Fₙ₊₁ / ∂xₙ)ᵀ λₙ₊₁ where the last term is omitted for step n = N and G is the objective function.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.solve_adjoint_sensitivities!","page":"Usage","title":"Jutul.solve_adjoint_sensitivities!","text":"solve_adjoint_sensitivities!(∇G, storage, states, state0, timesteps, G; forces)\n\nNon-allocating version of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.solve_numerical_sensitivities","page":"Usage","title":"Jutul.solve_numerical_sensitivities","text":"solve_numerical_sensitivities(model, states, reports, G, target;\n                                            forces = setup_forces(model),\n                                            state0 = setup_state(model),\n                                            parameters = setup_parameters(model),\n                                            epsilon = 1e-8)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nThis method uses numerical perturbation and is primarily intended for testing of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_parameter_optimization","page":"Usage","title":"Jutul.setup_parameter_optimization","text":"setup_parameter_optimization(model, state0, param, dt, forces, G, opt_cfg = optimization_config(model, param);\n                                                        grad_type = :adjoint,\n                                                        config = nothing,\n                                                        print = 1,\n                                                        copy_case = true,\n                                                        param_obj = false,\n                                                        kwarg...)\n\nSet up function handles for optimizing the case defined by the inputs to simulate together with a per-timestep objective function G. The objective should be on the form of sum over all steps, where each element of the sum is evaluated by model, state, dt, step_no, forces.\n\nGenerally calling either of the functions will mutate the data Dict. The options are: Fo(x) -> evaluate objective dFo(dFdx, x) -> evaluate gradient of objective, mutating dFdx (may trigger evaluation of Fo) Fand_dF(F, dFdx, x) -> evaluate F and/or dF. Value of nothing will mean that the corresponding entry is skipped.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Generic-optimization-interface","page":"Usage","title":"Generic optimization interface","text":"","category":"section"},{"location":"usage/#Jutul.DictOptimization.DictParameters","page":"Usage","title":"Jutul.DictOptimization.DictParameters","text":"DictParameters(parameters)\nDictParameters(parameters::AbstractDict, setup_function = missing;\n        strict = true,\n        verbose = true,\n        active_type = Float64\n    )\n\nSet up a DictParameters object for optimization. Optionally, the setup function that takes an instance with the same keys as parameters together with a step_info dictionary can be provided. The setup function should return a JutulCase set up from the parameters in the Dict.\n\nOptional keyword arguments:\n\nstrict: If true, the optimization will throw an error if any of the parameters are not set with at least one of the upper or lower bounds.\nverbose: If true, the optimization will print information about the optimization process.\nactive_type: The type of the parameters that are considered active in the optimization. Defaults to Float64. This is used to determine which parameters are active and should be optimized. This means that all entries (and entries in nested dictionaries) of the parameters dictionary must be of this type or an array with this type as element type.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.DictOptimization.free_optimization_parameter!","page":"Usage","title":"Jutul.DictOptimization.free_optimization_parameter!","text":"free_optimization_parameter!(dopt, \"parameter_name\", rel_min = 0.01, rel_max = 100.0)\nfree_optimization_parameter!(dopt, [\"dict_name\", \"parameter_name\"], abs_min = -8.0, abs_max = 7.0)\n\nFree an existing parameter for optimization in the DictParameters object. This will allow the parameter to be optimized through a call to optimize.\n\nNesting structures\n\nIf your DictParameters has a nesting structure, you can use a vector of strings or symbols to specify the parameter name, e.g. [\"dict_name\", \"parameter_name\"] to access the parameter located at [\"dict_name\"][\"parameter_name\"].\n\nSetting limits\n\nThe limits can be set using the following keyword arguments:\n\nabs_min: Absolute minimum value for the parameter.  If not set, no absolute minimum will be applied.\nabs_max: Absolute maximum value for the parameter. If not set, no absolute maximum will be applied.\nrel_min: Relative minimum value for the parameter. If not set, no relative minimum will be applied.\nrel_max: Relative maximum value for the parameter. If not set, no relative maximum will be applied.\n\nFor either of these entries it is possible to pass either a scalar, or an array. If an array is passed, it must have the same size as the parameter being set.\n\nNote that if dopt.strict is set to true, at least one of the upper or lower bounds must be set for free parameters. If dopt.strict is set to false, the bounds are optional and the DictParameters object can be used to compute sensitivities, but the built-in optimization routine assumes that finite limits are set for all parameters.\n\nOther keyword arguments\n\ninitial: Initial value for the parameter. If not set, the current value in dopt.parameters will be used.\nscaler=missing: Optional scaler for the parameter. If not set, no scaling will be applied. Available scalers are :log, :exp. The scaler will be applied\nlumping=missing: Optional lumping array for the parameter. If not set, no lumping will be applied. The lumping array should have the same size as the parameter and contain positive integers. The lumping array defines groups of indices that should be lumped together, i.e. the same value will be used for all indices in the same group. The lumping array should contain all integers from 1 to the maximum value in the array, and all indices in the same group should have the same value in the initial parameter, otherwise an error will be thrown.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.DictOptimization.freeze_optimization_parameter!","page":"Usage","title":"Jutul.DictOptimization.freeze_optimization_parameter!","text":"freeze_optimization_parameter!(dopt, \"parameter_name\")\nfreeze_optimization_parameter!(dopt, [\"dict_name\", \"parameter_name\"])\nfreeze_optimization_parameter!(dopt::DictParameters, parameter_name, val = missing)\n\nFreeze an optimization parameter in the DictParameters object. This will remove the parameter from the optimization targets and set its value to val if provided. Any limits/lumping/scaling settings for this parameter will be removed.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.DictOptimization.set_optimization_parameter!","page":"Usage","title":"Jutul.DictOptimization.set_optimization_parameter!","text":"set_optimization_parameter!(dopt::DictParameters, parameter_name, value)\n\nSet a specific optimization parameter in the DictParameters object. This function will update the value of the parameter in the dopt.parameters dictionary.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.DictOptimization.optimize","page":"Usage","title":"Jutul.DictOptimization.optimize","text":"optimized_dict = optimize(dopt, objective)\noptimize(dopt::DictParameters, objective, setup_fn = dopt.setup_function;\n    grad_tol = 1e-6,\n    obj_change_tol = 1e-6,\n    max_it = 25,\n    opt_fun = missing,\n    maximize = false,\n    simulator = missing,\n    config = missing,\n    solution_history = false,\n    backend_arg = (\n        use_sparsity = false,\n        di_sparse = true,\n        single_step_sparsity = false,\n        do_prep = true,\n    ),\n    kwarg...\n)\n\nOptimize parameters defined in a DictParameters object using the provided objective function. At least one variable has to be declared to be free using free_optimization_parameter! prior to calling the optimizer.\n\nArguments\n\ndopt::DictParameters: Container with parameters to optimize\nobjective: The objective function to minimize (or maximize)\nsetup_fn: Function to set up the optimization problem. Defaults to dopt.setup_function\n\nKeyword Arguments\n\ngrad_tol: Gradient tolerance for stopping criterion\nobj_change_tol: Objective function change tolerance for stopping criterion\nmax_it: Maximum number of iterations\nopt_fun: Optional custom optimization function. If missing, L-BFGS will be used\nmaximize: Set to true to maximize the objective instead of minimizing\nsimulator: Optional simulator object used in forward simulations\nconfig: Optional configuration for the setup\nsolution_history: If true, stores all intermediate solutions\nbackend_arg: Options for the autodiff backend:\nuse_sparsity: Enable sparsity detection for the objective function\ndi_sparse: Use sparse differentiation\nsingle_step_sparsity: Enable single step sparsity detection (if sparsity does not change during timesteps)\ndo_prep: Perform preparation step\n\nReturns\n\nThe optimized parameters as a dictionary.\n\nNotes\n\nThe function stores the optimization history and optimized parameters in the input dopt object.\nIf solution_history is true, intermediate solutions are stored in dopt.history.solutions.\nThe default optimization algorithm is L-BFGS with box constraints.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.DictOptimization.parameters_gradient","page":"Usage","title":"Jutul.DictOptimization.parameters_gradient","text":"parameters_gradient(dopt::DictParameters, objective, setup_fn = dopt.setup_function)\n\nCompute the gradient of the objective function with respect to the parameters defined in the DictParameters object. This function will return the gradient as a dictionary with the same structure as the input parameters, where each entry is a vector of gradients for each parameter. Only gradients with respect to free parameters will be computed.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Linear-solvers","page":"Usage","title":"Linear solvers","text":"","category":"section"},{"location":"usage/#Jutul.GenericKrylov","page":"Usage","title":"Jutul.GenericKrylov","text":"GenericKrylov(solver = :gmres; preconditioner = nothing; <kwarg>)\n\nSolver that wraps Krylov.jl with support for preconditioning.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.LUSolver","page":"Usage","title":"Jutul.LUSolver","text":"LUSolver(; reuse_memory = true, check = true, max_size = 50000)\n\nDirect solver that calls lu directly. Direct solvers are highly accurate, but are costly in terms of memory usage and execution speed for larger systems.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Preconditioners","page":"Usage","title":"Preconditioners","text":"","category":"section"},{"location":"usage/#Jutul.AMGPreconditioner","page":"Usage","title":"Jutul.AMGPreconditioner","text":"AMG on CPU (Julia native)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.ILUZeroPreconditioner","page":"Usage","title":"Jutul.ILUZeroPreconditioner","text":"ILU(0) preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JacobiPreconditioner","page":"Usage","title":"Jutul.JacobiPreconditioner","text":"Damped Jacobi preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.SPAI0Preconditioner","page":"Usage","title":"Jutul.SPAI0Preconditioner","text":"Sparse Approximate Inverse preconditioner of lowest order – SPAI(0)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.LUPreconditioner","page":"Usage","title":"Jutul.LUPreconditioner","text":"Full LU factorization as preconditioner (intended for smaller subsystems)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.GroupWisePreconditioner","page":"Usage","title":"Jutul.GroupWisePreconditioner","text":"Multi-model preconditioners\n\n\n\n\n\n","category":"type"},{"location":"usage/#Execution-contexts","page":"Usage","title":"Execution contexts","text":"","category":"section"},{"location":"usage/#Jutul.DefaultContext","page":"Usage","title":"Jutul.DefaultContext","text":"Default context\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.ParallelCSRContext","page":"Usage","title":"Jutul.ParallelCSRContext","text":"A context that uses a CSR sparse matrix format together with threads. Experimental.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Meshes-and-mesh-utilities","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"","category":"section"},{"location":"mesh/#Mesh-types","page":"Meshes and mesh utilities","title":"Mesh types","text":"","category":"section"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"Jutul has two main internal mesh types: Cartesian meshes and unstructured meshes. The unstructured format is a general polyhedral mesh format, and a Cartesian mesh can easily be converted to an unstructured mesh. Coarsened meshes can be created by a fine scale mesh and a partition vector.","category":"page"},{"location":"mesh/#Jutul.JutulMesh","page":"Meshes and mesh utilities","title":"Jutul.JutulMesh","text":"A mesh is a type of domain that has been discretized. Abstract subtype.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.CartesianMesh","page":"Meshes and mesh utilities","title":"Jutul.CartesianMesh","text":"CartesianMesh(dims, [Δ, [origin]])\n\nCreate a Cartesian mesh with dimensions specified by the Tuple dims.\n\nArguments\n\ndims::Tuple: Number of grid cells in each direction. For example, (nx, ny) will give a 2D grids with nx cells in the x-direction.\nΔ::Tuple=Tuple(ones(length(dims))): Equal length to dims. First option: A\n\nTuple of scalars where each entry is the length of each cell in that direction. For example, specifying (Δx, Δy) for a uniform grid with each grid cell having area ofΔx*Δy. Second option: ATuple` of vectors where each entry contains the cell sizes in the direction.\n\norigin=zeros(length(dims)): The origin of the first corner in the grid.\n\nExamples\n\nGenerate a uniform 3D mesh that discretizes a domain of 2 by 3 by 5 units with 3 by 5 by 2 cells:\n\njulia> CartesianMesh((3, 5, 2), (2.0, 3.0, 5.0))\nCartesianMesh (3D) with 3x5x2=30 cells\n\nGenerate a non-uniform 2D mesh:\n\njulia> CartesianMesh((2, 3), ([1.0, 2.0], [0.1, 3.0, 2.5]))\nCartesianMesh (2D) with 2x3x1=6 cells\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.UnstructuredMesh","page":"Meshes and mesh utilities","title":"Jutul.UnstructuredMesh","text":"UnstructuredMesh(g::CartesianMesh)\n\nConvert CartesianMesh instance to unstructured grid. Note that the mesh must be 2D and 3D for a 1-to-1 conversion. 1D meshes are implicitly converted to 2D.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.CoarseMesh","page":"Meshes and mesh utilities","title":"Jutul.CoarseMesh","text":"CoarseMesh(G::JutulMesh, p)\n\nConstruct a coarse mesh from a given JutulMesh that can be converted to an UnstructuredMesh instance. The second argument p should be a partition Vector with one entry per cell in the original grid that assigns that cell to a coarse block. Should be one-indexed and the numbering should be sequential and contain at least one fine cell for each coarse index. This is tested by the function.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.MRSTWrapMesh","page":"Meshes and mesh utilities","title":"Jutul.MRSTWrapMesh","text":"MRSTWrapMesh(G, N = nothing)\n\nMesh that adapts an exported MRST mesh to the Jutul interface. G is assumed to be read directly from file using MAT.matread. The raw exported grid can be found under the data field.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Plotting-functions","page":"Meshes and mesh utilities","title":"Plotting functions","text":"","category":"section"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"Plotting requires that a Makie backend is loaded (typically GLMakie or CairoMakie). The documentation uses CairoMakie to work on machines without OpenGL enabled, but if you want fast and interactive plots, GLMakie should be preferred.","category":"page"},{"location":"mesh/#Non-mutating","page":"Meshes and mesh utilities","title":"Non-mutating","text":"","category":"section"},{"location":"mesh/#Jutul.plot_mesh","page":"Meshes and mesh utilities","title":"Jutul.plot_mesh","text":"plot_mesh(mesh)\nplot_mesh(mesh;\n    cells = nothing,\n    faces = nothing,\n    boundaryfaces = nothing,\n    outer = false,\n    color = :lightblue,\n)\n\nPlot a mesh with uniform colors. Optionally, indices cells, faces or boundaryfaces can be passed to limit the plotting to a specific selection of entities.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_cell_data","page":"Meshes and mesh utilities","title":"Jutul.plot_cell_data","text":"plot_cell_data(mesh::JutulMesh, data::Vector; kwarg...)\nplot_cell_data(mesh, data;\n    cells = nothing,\n    faces = nothing,\n    boundaryfaces = nothing\n)\n\nPlot cell-wise values (as a vector) on the mesh. Optionally, indices cells, faces or boundaryfaces can be passed to limit the plotting to a specific selection of entities.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_mesh_edges","page":"Meshes and mesh utilities","title":"Jutul.plot_mesh_edges","text":"plot_mesh_edges(mesh; kwarg...)\n\nPlot the edges of all cells on the exterior of a mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_interactive","page":"Meshes and mesh utilities","title":"Jutul.plot_interactive","text":"plot_interactive(mesh, vector_of_dicts; kwarg...)\n\nLaunch an interactive plot of a mesh with the given vector_of_dicts (or just a dict). Each dict can have cell data either as vectors (one value per cell) or matrices (one column per cell).\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Mutating","page":"Meshes and mesh utilities","title":"Mutating","text":"","category":"section"},{"location":"mesh/#Jutul.plot_mesh!","page":"Meshes and mesh utilities","title":"Jutul.plot_mesh!","text":"plot_mesh!(ax, mesh)\n\nMutating version of plot_mesh that plots into an existing Makie Axis instance.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_cell_data!","page":"Meshes and mesh utilities","title":"Jutul.plot_cell_data!","text":"plot_cell_data!(ax, mesh, data; kwarg...)\n\nMutating version of plot_cell_data that plots into an existing Makie Axis\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_mesh_edges!","page":"Meshes and mesh utilities","title":"Jutul.plot_mesh_edges!","text":"plot_mesh_edges!(ax, mesh; kwarg...)\n\nPlot the edges of all cells on the exterior of a mesh into existing Makie Axis ax.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Example:-Cartesian-meshes","page":"Meshes and mesh utilities","title":"Example: Cartesian meshes","text":"","category":"section"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"For example, we can make a small 2D mesh with given physical dimensions and convert it:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using Jutul\nnx = 10\nny = 5\ng2d_cart = CartesianMesh((nx, ny), (100.0, 50.0))","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"g2d = UnstructuredMesh(g2d_cart)","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"We can then plot it, colorizing each cell by its enumeration:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using CairoMakie\nfig, ax, plt = plot_cell_data(g2d, 1:number_of_cells(g2d))\nplot_mesh_edges!(ax, g2d)\nfig","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"If we want to drill down a bit further, we can make a plot:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"We can make a 3D mesh in the same manner:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"nz = 3\ng3d = UnstructuredMesh(CartesianMesh((nx, ny, nz), (100.0, 50.0, 30.0)))","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"And plot it the same way:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using CairoMakie\nnc = number_of_cells(g3d)\nfig, ax, plt = plot_cell_data(g3d, 1:nc)\nplot_mesh_edges!(ax, g3d)\nfig","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"We can also plot only a subset of cells:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using CairoMakie\nfig, ax, plt = plot_cell_data(g3d, 1:nc, cells = 1:2:nc)\nfig","category":"page"},{"location":"mesh/#Mesh-API-functions","page":"Meshes and mesh utilities","title":"Mesh API functions","text":"","category":"section"},{"location":"mesh/#Queries","page":"Meshes and mesh utilities","title":"Queries","text":"","category":"section"},{"location":"mesh/#Jutul.number_of_cells","page":"Meshes and mesh utilities","title":"Jutul.number_of_cells","text":"number_of_cells(D::Union{DataDomain, DiscretizedDomain})\n\nGet the number of cells in a DataDomain or DiscretizedDomain.\n\n\n\n\n\nnumber_of_cells(g)::Integer\n\nGet the number of cells in a mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.number_of_faces","page":"Meshes and mesh utilities","title":"Jutul.number_of_faces","text":"number_of_faces(D::Union{DataDomain, DiscretizedDomain})\n\nGet the number of faces in a DataDomain or DiscretizedDomain.\n\n\n\n\n\nnumber_of_faces(g)::Integer\n\nGet the number of faces in a mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.number_of_boundary_faces","page":"Meshes and mesh utilities","title":"Jutul.number_of_boundary_faces","text":"number_of_boundary_faces(g)\n\nGet the number of boundary/exterior faces in a mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Manipulation","page":"Meshes and mesh utilities","title":"Manipulation","text":"","category":"section"},{"location":"mesh/#Jutul.extrude_mesh","page":"Meshes and mesh utilities","title":"Jutul.extrude_mesh","text":"extrude_mesh(m2d::UnstructuredMesh, nlayers)\nextrude_mesh(m2d::UnstructuredMesh, [1, 2, 5, 10])\n\nExtrude a 2D mesh into a 3D mesh by adding layers of cells in the z-direction. The number of layers can be specified as an integer or as an array of depths. The depths must be in increasing order.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.extract_submesh","page":"Meshes and mesh utilities","title":"Jutul.extract_submesh","text":"extract_submesh(g::UnstructuredMesh, cells)\n\nExtract a subgrid for a given mesh and a iterable of cells to keep.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Example:-Mesh-manipulation","page":"Meshes and mesh utilities","title":"Example: Mesh manipulation","text":"","category":"section"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"We can quickly build new meshes by applying transformations to an already existing mesh. Let us create a Cartesian mesh and extract the cells that lie within a circle:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using Jutul, CairoMakie\ng = UnstructuredMesh(CartesianMesh((10, 10), (1.0, 1.0)))\ngeo = tpfv_geometry(g)\nkeep = Int[]\nfor c in 1:number_of_cells(g)\n    x, y = geo.cell_centroids[:, c]\n    if (x - 0.5)^2 + (y - 0.5)^2 < 0.25\n        push!(keep, c)\n    end\nend\nsubg = extract_submesh(g, keep)\nfig, ax, plt = plot_mesh(subg)\nplot_mesh_edges!(ax, g, color = :red)\nfig","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"We can turn this into a 3D mesh by extruding it, and then tweak the nodes:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"g3d = Jutul.extrude_mesh(subg, 20)\nfor node in eachindex(subg.node_points)\n    g3d.node_points[node] += 0.01*rand(3)\nend\nfig, ax, plt = plot_mesh(g3d)\nfig","category":"page"},{"location":"mesh/#Geometry","page":"Meshes and mesh utilities","title":"Geometry","text":"","category":"section"},{"location":"mesh/#Jutul.TwoPointFiniteVolumeGeometry","page":"Meshes and mesh utilities","title":"Jutul.TwoPointFiniteVolumeGeometry","text":"TwoPointFiniteVolumeGeometry(neighbors, areas, volumes, normals, cell_centers, face_centers)\n\nStore two-point geometry information for a given list of neighbors specified as a 2 by n matrix where n is the number of faces such that face i connectes cells N[1, i] and N[2, i].\n\nThe two-point finite-volume geometry contains the minimal set of geometry information required to compute standard finite-volume discretizations.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.tpfv_geometry","page":"Meshes and mesh utilities","title":"Jutul.tpfv_geometry","text":"tpfv_geometry(g)\n\nGenerate two-point finite-volume geometry for a given grid, if supported.\n\nSee also TwoPointFiniteVolumeGeometry.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.find_enclosing_cells","page":"Meshes and mesh utilities","title":"Jutul.find_enclosing_cells","text":"find_enclosing_cells(G, traj; geometry = tpfv_geometry(G), n = 25)\n\nFind the cell indices of cells in the mesh G that are intersected by a given trajectory traj. traj can be either a matrix with equal number of columns as dimensions in G (i.e. three columns for 3D) or a Vector of SVector instances with the same length.\n\nThe optional argument geometry is used to define the centroids and normals used in the calculations. You can precompute this if you need to perform many searches. The keyword argument n can be used to set the number of discretizations in each segment.\n\nuse_boundary is by default set to false. If set to true, the boundary faces of cells are treated more rigorously when picking exactly what cells are cut by a trajectory, but this requires that the boundary normals are oriented outwards, which is currently not the case for all meshes from downstream packages.\n\nlimit_box speeds up the search by limiting the search to the minimal bounding box that contains both the trajectory and the mesh. This can be turned off by passing false. There should be no difference in the cells tagged by changing this option.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.cells_inside_bounding_box","page":"Meshes and mesh utilities","title":"Jutul.cells_inside_bounding_box","text":"cells_inside_bounding_box(G::UnstructuredMesh, low_bb, high_bb; algorithm = :box, atol = 0.01)\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Example:-Cell-intersection","page":"Meshes and mesh utilities","title":"Example: Cell intersection","text":"","category":"section"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using CairoMakie, Jutul\n# 3D mesh\nG = CartesianMesh((4, 4, 5), (100.0, 100.0, 100.0))\ntrajectory = [\n    50.0 25.0 1;\n    55 35.0 25;\n    65.0 40.0 50.0;\n    70.0 70.0 90.0\n]\n\ncells = Jutul.find_enclosing_cells(G, trajectory)\n\n# Optional plotting, requires Makie:\nfig, ax, plt = Jutul.plot_mesh_edges(G)\nplot_mesh!(ax, G, cells = cells, alpha = 0.5, transparency = true)\nlines!(ax, trajectory, linewidth = 10)\nfig","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"2D version:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using CairoMakie, Jutul\n# 2D mesh\nG = CartesianMesh((50, 50), (1.0, 2.0))\ntrajectory = [\n    0.1 0.1;\n    0.2 0.4;\n    0.3 1.2\n]\nfig, ax, plt = Jutul.plot_mesh_edges(G)\ncells = Jutul.find_enclosing_cells(G, trajectory)\n# Plotting, needs Makie\nfig, ax, plt = Jutul.plot_mesh_edges(G)\nplot_mesh!(ax, G, cells = cells, alpha = 0.5, transparency = true)\nlines!(ax, trajectory[:, 1], trajectory[:, 2], linewidth = 3)\nfig","category":"page"},{"location":"mesh/#Mesh-generation","page":"Meshes and mesh utilities","title":"Mesh generation","text":"","category":"section"},{"location":"mesh/#Gmsh-support","page":"Meshes and mesh utilities","title":"Gmsh support","text":"","category":"section"},{"location":"mesh/#Jutul.mesh_from_gmsh","page":"Meshes and mesh utilities","title":"Jutul.mesh_from_gmsh","text":"G = mesh_from_gmsh(pth)\nG = mesh_from_gmsh()\nG = mesh_from_gmsh(pth; verbose = true)\n\nParse a Gmsh file and return a Jutul UnstructuredMesh (in 3D only). Requires the Gmsh.jl package to be loaded. If no path is provided in pth it is assumed that you are managing the Gmsh state manually and it will use the current selected mesh inside Gmsh. Please note that Gmsh is GPL licensed unless you have obtained another type of license from the authors.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Radial-mesh","page":"Meshes and mesh utilities","title":"Radial mesh","text":"","category":"section"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using Jutul, CairoMakie\nimport Jutul.RadialMeshes: radial_mesh\nimport Jutul: plot_mesh_edges\nnangle = 10\nradii = [0.2, 0.5, 1.0]\nm = radial_mesh(nangle, radii; centerpoint = true)\nplot_mesh_edges(m)","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"Radial meshes can still be indexed as Cartesian meshes:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"IJ = map(i -> cell_ijk(m, i), 1:number_of_cells(m))","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"fig, ax, plt = plot_cell_data(m, map(first, IJ))\nfig","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"fig, ax, plt = plot_cell_data(m, map(ijk -> ijk[2], IJ))\nfig","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"We can also plot the faces by using the nodes together with standard Makie plotting calls. We regenerate the mesh and make it contain a single cell in the middle before plotting it:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"m = radial_mesh(nangle, radii; centerpoint = false)\nncells = number_of_cells(m)\nfig, ax, plt = plot_cell_data(m, 1:ncells, alpha = 0.25)\nscatter!(ax, m.node_points)\nfor face in 1:number_of_faces(m)\n    n1, n2 = m.faces.faces_to_nodes[face]\n    pt1 = m.node_points[n1]\n    pt2 = m.node_points[n2]\n    lines!(ax, [pt1, pt2], color = :red)\nend\n\nfor bface in 1:number_of_boundary_faces(m)\n    n1, n2 = m.boundary_faces.faces_to_nodes[bface]\n    pt1 = m.node_points[n1]\n    pt2 = m.node_points[n2]\n    lines!(ax, [pt1, pt2], color = :blue)\nend\nfig","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"We can also zoom in on a single cell and plot the oriented normals:","category":"page"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using LinearAlgebra\ngeo = tpfv_geometry(m)\ncellno = 1\nfig, ax, plt = plot_mesh(m, cells = cellno)\nfor face in m.faces.cells_to_faces[cellno]\n    n1, n2 = m.faces.faces_to_nodes[face]\n    @info \"Interior edge $n1 to $n2\"\n    pt1 = m.node_points[n1]\n    pt2 = m.node_points[n2]\n    lines!(ax, [pt1, pt2], color = :red)\n    midpt = (pt1 + pt2) / 2\n    if m.faces.neighbors[face][1] == cellno\n        sgn = 1\n    else\n        sgn = -1\n    end\n    lines!(ax, [midpt, midpt + sgn*norm(pt2 - pt1, 2)*geo.normals[:, face]], color = :orange)\nend\nfor bface in m.boundary_faces.cells_to_faces[cellno]\n    n1, n2 = m.boundary_faces.faces_to_nodes[bface]\n    @info \"Exterior edge $n1 to $n2\"\n    pt1 = m.node_points[n1]\n    pt2 = m.node_points[n2]\n    lines!(ax, [pt1, pt2], color = :blue)\n    midpt = (pt1 + pt2) / 2\n    lines!(ax, [midpt, midpt + norm(pt2 - pt1, 2)*geo.boundary_normals[:, bface]], color = :green)\nend\nscatter!(ax, m.node_points)\nfig","category":"page"},{"location":"mesh/#Spiral-meshes","page":"Meshes and mesh utilities","title":"Spiral meshes","text":"","category":"section"},{"location":"mesh/#Jutul.RadialMeshes.spiral_mesh","page":"Meshes and mesh utilities","title":"Jutul.RadialMeshes.spiral_mesh","text":"mesh = spiral_mesh(10, 3, spacing = [0.0, 0.5, 1.0])\n\nSpiral mesh generator. Generates a spiral mesh in 2D with an optional \"spacing\" subdiscretization between each segment.\n\n\n\n\n\n","category":"function"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"using Jutul, CairoMakie\nimport Jutul.RadialMeshes: spiral_mesh\nn_angular_sections = 10\nnrotations = 4\nspacing = [0.0, 0.5, 1.0]\nrmesh = spiral_mesh(n_angular_sections, nrotations, spacing = spacing)\nnum_cells = number_of_cells(rmesh)\n\nfig, ax, plt = plot_cell_data(rmesh, 1:number_of_cells(rmesh))\nfig","category":"page"},{"location":"mesh/#Jutul.RadialMeshes.spiral_mesh_tags","page":"Meshes and mesh utilities","title":"Jutul.RadialMeshes.spiral_mesh_tags","text":"spiral_mesh_tags(rmesh, spacing = missing)\n\nGet the tags for a spiral mesh. If spacing is provided, it will also return the spacing and winding tags.\n\n\n\n\n\n","category":"function"},{"location":"mesh/","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"import Jutul.RadialMeshes: spiral_mesh_tags\ntags = spiral_mesh_tags(rmesh, spacing)\nfig = Figure(size = (400, 1800))\nfor (figno, pp) in enumerate(pairs(tags))\n    k, val = pp\n    ax = Axis(fig[figno, 1], title = \"Spiral tag $k\")\n    plot_cell_data!(ax, rmesh, val)\nend\nfig","category":"page"},{"location":"#Jutul-documentation","page":"Home","title":"Jutul documentation","text":"","category":"section"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Jutul is an experimental Julia framework for multiphysics processes based on implicit finite-volume methods with automatic differentiation. The main public demonstrator is JutulDarcy.jl - a fully differentiable porous media simulator with excellent performance.","category":"page"},{"location":"#An-example","page":"Home","title":"An example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Jutul is primarily intended to build applications. The base library includes a few \"hello world\"-type PDE solvers that are used for testing. One of these is the standard 2D heat equation on residual form:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial Tpartial t - fracpartial^2 Tpartial x^2 - fracpartial^2 Tpartial y^2 = 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The test solver uses a structured grid and a central difference scheme with periodic boundary conditions to solve this system. You can view the complete source code for this solver here.","category":"page"},{"location":"#Simulation-loop","page":"Home","title":"Simulation loop","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We demonstrate how to set up the simulation loop. This essentially boils down to three things: Setting up a grid/model, setting initial condition and picking time-steps where the solver should report output:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Jutul\nsys = SimpleHeatSystem()\n# Create a 100x100 grid\nnx = ny = 100\nL = 100.0\nH = 100.0\ng = CartesianMesh((nx, ny), (L, H))\n# Create a data domain with geometry information\nD = DataDomain(g)\n# Set up a model with the grid and system\nmodel = SimulationModel(D, sys)\n# Initial condition is random values\nnc = number_of_cells(g)\nT0 = zeros(nc)\nx = D[:cell_centroids][1, :]\ny = D[:cell_centroids][2, :]\n# Create initial peak of heat to diffuse out.\nfor i in 1:nc\n    if (x[i] > 0.25*L) & (x[i] < 0.75*L) & (y[i] > 0.25*H) & (y[i] < 0.75*H)\n        T0[i] = 100.0\n    end\nend\nstate0 = setup_state(model, Dict(:T=>T0))\nsim = Simulator(model, state0 = state0)\ndt = fill(1.0, 100)\nstates, = simulate(sim, dt, info_level = 1);","category":"page"},{"location":"#Visualizing-the-results","page":"Home","title":"Visualizing the results","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If using Julia 1.9 or later, visualization is provided if a version of Makie is included. In the documentation we use CairoMakie as it can produce plots on servers without rendering capabilities, such as the one where the Jutul continious integration is running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are running this locally and want interactive plots you can instead use the GLMakie backend.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GLMakie\nGLMakie.activate!()","category":"page"},{"location":"","page":"Home","title":"Home","text":"We plot the initial conditions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fig, ax = plot_cell_data(g, state0[:T])\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then plot the final state, observing significant diffusion from the sharp initial state.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fig, ax = plot_cell_data(g, states[end][:T])\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is also interactive plotting that allows you to step through each time-step. This is most relevant when using GLMakie to plot, otherwise the figure will be static.","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot_interactive(g, [state0; states])","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"internals/#Internal-docstrings","page":"Internals","title":"Internal docstrings","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"These functions are mostly relevant for implementing simulators in the Jutul framework.","category":"page"},{"location":"internals/#Entities-and-variables","page":"Internals","title":"Entities and variables","text":"","category":"section"},{"location":"internals/#Variables","page":"Internals","title":"Variables","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Variable types:","category":"page"},{"location":"internals/#Jutul.JutulVariables","page":"Internals","title":"Jutul.JutulVariables","text":"Abstract type for all variables in Jutul.\n\nA variable is associated with a JutulEntity through the associated_entity function. A variable is local to that entity, and cannot depend on other entities. Variables are used by models to define:\n\nprimary variables: Sometimes referred to as degrees of freedom, primary unknowns or solution variables\nparameters: Static quantities that impact the solution\nsecondary variables: Can be computed from a combination of other primary and secondary variables and parameters.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.ScalarVariable","page":"Internals","title":"Jutul.ScalarVariable","text":"Abstract type for scalar variables (one entry per entity, e.g. pressure or temperature in each cell of a model)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.VectorVariables","page":"Internals","title":"Jutul.VectorVariables","text":"Abstract type for vector variables (more than one entry per entity, for example saturations or displacements)\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Internals","title":"Internals","text":"Variables API:","category":"page"},{"location":"internals/#Jutul.degrees_of_freedom_per_entity","page":"Internals","title":"Jutul.degrees_of_freedom_per_entity","text":"Number of independent primary variables / degrees of freedom per computational entity.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.values_per_entity","page":"Internals","title":"Jutul.values_per_entity","text":"Number of values held by a primary variable. Normally this is equal to the number of degrees of freedom, but some special primary variables are most conveniently defined by having N values and N-1 independent variables.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.maximum_value","page":"Internals","title":"Jutul.maximum_value","text":"Upper (inclusive) limit for variable.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.minimum_value","page":"Internals","title":"Jutul.minimum_value","text":"Lower (inclusive) limit for variable.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.variable_scale","page":"Internals","title":"Jutul.variable_scale","text":"Define a \"typical\" numerical value for a variable to scale the linear system entries.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.absolute_increment_limit","page":"Internals","title":"Jutul.absolute_increment_limit","text":"Absolute allowable change for variable during a nonlinear update.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.relative_increment_limit","page":"Internals","title":"Jutul.relative_increment_limit","text":"Relative allowable change for variable during a nonlinear update. A variable with value |x| and relative limit 0.2 cannot change more than |x|*0.2.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.associated_entity","page":"Internals","title":"Jutul.associated_entity","text":"Return the domain entity the equation is associated with\n\n\n\n\n\nThe entity a variable is associated with, and can hold partial derivatives with respect to.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"Updating variables","category":"page"},{"location":"internals/#Jutul.@jutul_secondary","page":"Internals","title":"Jutul.@jutul_secondary","text":"Designate the function as updating a secondary variable.\n\nA generic evaluator is then defined, together with a function for getting the dependencies of that function upon the state. This is most easily documented with an example. If we define the following function annotated with the macro when updating the array containing the values of MyVarType realized for some model:\n\n@jutul_secondary function some_fn!(target, var::MyVarType, model, a, b, c, ix)\n    for i in ix\n        target[i] = a[i] + b[i] / c[i]\n    end\nend\n\nThe purpose of the macro is to translate this into two functions. The first defines for the dependencies of the function with respect to the fields of the state (primary variables, secondary variables and parameters):\n\nfunction get_dependencies(var::MyVarType, model)\n   return (:a, :b, :c)\nend\n\nThe second function defines a generic version that takes in state, and automatically expands the set of dependencies into getfield calls.\n\nfunction update_secondary_variable!(array_target, var::MyVarType, model, state, ix)\n    some_fn!(array_target, var, model, state.a, state.b, state.c, ix)\nend\n\nNote that the input names of arguments 4 to end-1 matter, as these will be fetched from state, exactly as written.\n\n\n\n\n\n","category":"macro"},{"location":"internals/#Jutul.get_dependencies","page":"Internals","title":"Jutul.get_dependencies","text":"Get dependencies of variable when viewed as a secondary variable. Normally autogenerated with @jutul_secondary\n\n\n\n\n\n","category":"function"},{"location":"internals/#Entities","page":"Internals","title":"Entities","text":"","category":"section"},{"location":"internals/#Jutul.JutulEntity","page":"Internals","title":"Jutul.JutulEntity","text":"Super-type for all entities where JutulVariables can be defined.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.Cells","page":"Internals","title":"Jutul.Cells","text":"Entity for Cells (closed volumes with averaged properties for a finite-volume solver)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.Faces","page":"Internals","title":"Jutul.Faces","text":"Entity for Faces (intersection between pairs of Cells)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.Nodes","page":"Internals","title":"Jutul.Nodes","text":"Entity for Nodes (intersection between multiple Faces)\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Internals","title":"Internals","text":"Entities API","category":"page"},{"location":"internals/#Jutul.number_of_partials_per_entity","page":"Internals","title":"Jutul.number_of_partials_per_entity","text":"number_of_partials_per_entity(model::SimulationModel, entity::JutulEntity)\n\nGet the number of local partial derivatives per entity in a model for a given JutulEntity. This is the sum of degrees_of_freedom_per_entity for all primary variables defined on entity.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.number_of_entities","page":"Internals","title":"Jutul.number_of_entities","text":"Get the number of entities (e.g. the number of cells) that the equation is defined on.\n\n\n\n\n\nGet number of entities a cache is defined on.\n\n\n\n\n\nNumber of entities for vector stored in state (just the number of elements)\n\n\n\n\n\nNumber of entities for matrix stored in state (convention is number of columns)\n\n\n\n\n\nNumber of entities (e.g. Cells, Faces) a variable is defined on. By default, each primary variable exists on all cells of a discretized domain\n\n\n\n\n\n","category":"function"},{"location":"internals/#Equations","page":"Internals","title":"Equations","text":"","category":"section"},{"location":"internals/#Jutul.JutulEquation","page":"Internals","title":"Jutul.JutulEquation","text":"Abstract type for all residual equations\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Internals","title":"Internals","text":"Equations API","category":"page"},{"location":"internals/#Jutul.number_of_equations","page":"Internals","title":"Jutul.number_of_equations","text":"Get the total number of equations on the domain of model.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.number_of_equations_per_entity","page":"Internals","title":"Jutul.number_of_equations_per_entity","text":"n = number_of_equations_per_entity(model::JutulModel, eq::JutulEquation)\n\nGet the number of equations per entity. For example, mass balance of two components will have two equations per grid cell (= entity)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Automatic-differentiation","page":"Internals","title":"Automatic differentiation","text":"","category":"section"},{"location":"internals/#Jutul.value","page":"Internals","title":"Jutul.value","text":"Take value of AD.\n\n\n\n\n\nvalue(d::Dict)\n\nCall value on all elements of some Dict.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.as_value","page":"Internals","title":"Jutul.as_value","text":"Create a mapped array that produces only the values when indexed.\n\nOnly useful for AD arrays, otherwise it does nothing.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.local_ad","page":"Internals","title":"Jutul.local_ad","text":"local_ad(state::T, index::I, ad_tag::∂T) where {T, I<:Integer, ∂T}\n\nCreate localad for state for index I of AD tag of type adtag\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.JutulAutoDiffCache","page":"Internals","title":"Jutul.JutulAutoDiffCache","text":"An AutoDiffCache is a type that holds both a set of AD values and a map into some global Jacobian.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.CompactAutoDiffCache","page":"Internals","title":"Jutul.CompactAutoDiffCache","text":"Cache that holds an AD vector/matrix together with their positions.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.allocate_array_ad","page":"Internals","title":"Jutul.allocate_array_ad","text":"allocate_array_ad(n[, m]; <keyword arguments>)\n\nAllocate vector or matrix as AD with optionally provided context and a specified non-zero on the diagonal.\n\nArguments\n\nn::Integer: number of entries in vector, or number of rows if m is given.\nm::Integer: number of rows (optional)\n\nKeyword arguments\n\nnpartials = 1: Number of partials derivatives to allocate for each element\ndiag_pos = nothing: Indices of where to put entities on the diagonal (if any)\n\nOther keyword arguments are passed onto get_ad_entity_scalar.\n\nExamples:\n\nAllocate a vector with a single partial:\n\njulia> allocate_array_ad(2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 1}}:\n Dual{nothing}(0.0,0.0)\n Dual{nothing}(0.0,0.0)\n\nAllocate a vector with two partials, and set the first to one:\n\njulia> allocate_array_ad(2, diag_pos = 1, npartials = 2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,1.0,0.0)\n\nSet up a matrix with two partials, where the first column has partials [1, 0] and the second [0, 1]:\n\njulia> allocate_array_ad(2, 2, diag_pos = [1, 2], npartials = 2)\n2×2 Matrix{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)  Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,0.0,1.0)  Dual{nothing}(0.0,0.0,1.0)\n\n\n\n\n\nallocate_array_ad(v::AbstractVector, ...)\n\nConvert vector to AD vector.\n\n\n\n\n\nallocate_array_ad(v::AbstractMatrix, ...)\n\nConvert matrix to AD matrix.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.get_ad_entity_scalar","page":"Internals","title":"Jutul.get_ad_entity_scalar","text":"get_ad_entity_scalar(v::Real, npartials, diag_pos = nothing; <keyword_arguments>)\n\nGet scalar with partial derivatives as AD instance.\n\nArguments\n\nv::Real: Value of AD variable.\nnpartials: Number of partial derivatives each AD instance holds.\ndiag_pos = nothing: Position(s) of where to set 1 as the partial derivative instead of zero.\n\nKeyword arguments\n\ntag = nothing: Tag for AD instance. Two AD values of the different tag cannot interoperate to avoid perturbation confusion (see ForwardDiff documentation).\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.get_entries","page":"Internals","title":"Jutul.get_entries","text":"Get the entries of the main autodiff cache for an equation.\n\nNote: This only gets the .equation field's entries.\n\n\n\n\n\nGet entries of autodiff cache. Entries are AD vectors that hold values and derivatives.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Matrix","page":"Internals","title":"Matrix","text":"","category":"section"},{"location":"internals/#Jutul.JutulMatrixLayout","page":"Internals","title":"Jutul.JutulMatrixLayout","text":"Abstract type for matrix layouts. A layout determines how primary variables and equations are ordered in a sparse matrix representation. Note that this is different from the matrix format itself as it concerns the ordering itself: For example, if all equations for a single cell come in sequence, or if a single equation is given for all entities before the next equation is written.\n\nDifferent layouts does not change the solution of the system, but different linear solvers support different layouts.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.EntityMajorLayout","page":"Internals","title":"Jutul.EntityMajorLayout","text":"Equations are grouped by entity, listing all equations and derivatives for entity 1 before proceeding to entity 2 etc.\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E2/∂S)₁, (∂E1/∂p)₂, (∂E2/∂S)₂\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.EquationMajorLayout","page":"Internals","title":"Jutul.EquationMajorLayout","text":"Equations are stored sequentially in rows, derivatives of same type in columns:\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E1/∂p)₂, (∂E2/∂S)₁, (∂E2/∂S)₂\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.BlockMajorLayout","page":"Internals","title":"Jutul.BlockMajorLayout","text":"Same as EntityMajorLayout, but the system is a sparse matrix where each entry is a small dense matrix.\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give a diagonal of length 2: [(∂E1/∂p)₁ (∂E1/∂S)₁ ; (∂E2/∂p)₁ (∂E2/∂S)₁] [(∂E1/∂p)₂ (∂E1/∂S)₂ ; (∂E2/∂p)₂ (∂E2/∂S)₂]\n\n\n\n\n\n","category":"type"},{"location":"internals/#Various","page":"Internals","title":"Various","text":"","category":"section"},{"location":"internals/#Jutul.convergence_criterion","page":"Internals","title":"Jutul.convergence_criterion","text":"convergence_criterion(model, storage, eq, eq_s, r; dt = 1)\n\nGet the convergence criterion values for a given equation. Can be checked against the corresponding tolerances.\n\nArguments\n\nmodel: model that generated the current equation.\nstorage: global simulator storage.\neq::JutulEquation: equation implementation currently being checked\neq_s: storage for eq where values are contained.\nr: the local residual part corresponding to this model, as a matrix with column index equaling entity index\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.partition","page":"Internals","title":"Jutul.partition","text":"partition(N::AbstractMatrix, num_coarse, weights = ones(size(N, 2)); partitioner = MetisPartitioner(), groups = nothing, n = maximum(N), group_by_weights = false, buffer_group = true)\n\nPartition based on neighborship (with optional groups kept contigious after partitioning)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.load_balanced_endpoint","page":"Internals","title":"Jutul.load_balanced_endpoint","text":"load_balanced_endpoint(block_index, nvals, nblocks)\n\nEndpoint for interval block_index that subdivides nvals into nblocks in a load balanced manner. This is done by adding one element to the first set of blocks whenever possible.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"<!– @autodocs  Modules = [Jutul] –>","category":"page"}]
}
