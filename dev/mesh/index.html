<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Meshes and mesh utilities · Jutul.jl</title><meta name="title" content="Meshes and mesh utilities · Jutul.jl"/><meta property="og:title" content="Meshes and mesh utilities · Jutul.jl"/><meta property="twitter:title" content="Meshes and mesh utilities · Jutul.jl"/><meta name="description" content="Documentation for Jutul.jl."/><meta property="og:description" content="Documentation for Jutul.jl."/><meta property="twitter:description" content="Documentation for Jutul.jl."/><meta property="og:url" content="https://sintefmath.github.io/Jutul.jl/mesh/"/><meta property="twitter:url" content="https://sintefmath.github.io/Jutul.jl/mesh/"/><link rel="canonical" href="https://sintefmath.github.io/Jutul.jl/mesh/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Jutul.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><a class="tocitem" href="../optimization/">Sensitivities, adjoints and optimization</a></li><li class="is-active"><a class="tocitem" href>Meshes and mesh utilities</a><ul class="internal"><li><a class="tocitem" href="#Mesh-types"><span>Mesh types</span></a></li><li><a class="tocitem" href="#Plotting-functions"><span>Plotting functions</span></a></li><li><a class="tocitem" href="#Example:-Cartesian-meshes"><span>Example: Cartesian meshes</span></a></li><li><a class="tocitem" href="#Mesh-API-functions"><span>Mesh API functions</span></a></li><li><a class="tocitem" href="#Example:-Mesh-manipulation"><span>Example: Mesh manipulation</span></a></li><li><a class="tocitem" href="#Example:-Cell-intersection"><span>Example: Cell intersection</span></a></li><li><a class="tocitem" href="#Mesh-generation"><span>Mesh generation</span></a></li></ul></li><li><a class="tocitem" href="../units/">Units</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Meshes and mesh utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Meshes and mesh utilities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sintefmath/Jutul.jl/blob/main/docs/src/mesh.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Meshes-and-mesh-utilities"><a class="docs-heading-anchor" href="#Meshes-and-mesh-utilities">Meshes and mesh utilities</a><a id="Meshes-and-mesh-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes-and-mesh-utilities" title="Permalink"></a></h1><h2 id="Mesh-types"><a class="docs-heading-anchor" href="#Mesh-types">Mesh types</a><a id="Mesh-types-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-types" title="Permalink"></a></h2><p>Jutul has two main internal mesh types: Cartesian meshes and unstructured meshes. The unstructured format is a general polyhedral mesh format, and a Cartesian mesh can easily be converted to an unstructured mesh. Coarsened meshes can be created by a fine scale mesh and a partition vector.</p><article><details class="docstring" open="true"><summary id="Jutul.JutulMesh"><a class="docstring-binding" href="#Jutul.JutulMesh"><code>Jutul.JutulMesh</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A mesh is a type of domain that has been discretized. Abstract subtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/core_types/core_types.jl#L514-L516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.CartesianMesh"><a class="docstring-binding" href="#Jutul.CartesianMesh"><code>Jutul.CartesianMesh</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CartesianMesh(dims, [Δ, [origin]])</code></pre><p>Create a Cartesian mesh with dimensions specified by the <code>Tuple</code> <code>dims</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dims::Tuple</code>: Number of grid cells in each direction. For example, <code>(nx, ny)</code> will give a 2D grids with <code>nx</code> cells in the x-direction.</li><li><code>Δ::Tuple=Tuple(ones(length(dims)))</code>: Equal length to <code>dims</code>. First option: A</li></ul><p><code>Tuple</code> of scalars where each entry is the length of each cell in that direction. For example, specifying <code>(Δx, Δy) for a uniform grid with each grid cell having area of</code>Δx*Δy<code>. Second option: A</code>Tuple` of vectors where each entry contains the cell sizes in the direction.</p><ul><li><code>origin=zeros(length(dims))</code>: The origin of the first corner in the grid.</li></ul><p><strong>Examples</strong></p><p>Generate a uniform 3D mesh that discretizes a domain of 2 by 3 by 5 units with 3 by 5 by 2 cells:</p><pre><code class="language-julia-repl hljs">julia&gt; CartesianMesh((3, 5, 2), (2.0, 3.0, 5.0))
CartesianMesh (3D) with 3x5x2=30 cells</code></pre><p>Generate a non-uniform 2D mesh:</p><pre><code class="language-julia-repl hljs">julia&gt; CartesianMesh((2, 3), ([1.0, 2.0], [0.1, 3.0, 2.5]))
CartesianMesh (2D) with 2x3x1=6 cells</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/cart.jl#L3-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.UnstructuredMesh"><a class="docstring-binding" href="#Jutul.UnstructuredMesh"><code>Jutul.UnstructuredMesh</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnstructuredMesh(g::CartesianMesh)</code></pre><p>Convert <code>CartesianMesh</code> instance to unstructured grid. Note that the mesh must be 2D and 3D for a 1-to-1 conversion. 1D meshes are implicitly converted to 2D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/unstructured/types.jl#L293-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.CoarseMesh"><a class="docstring-binding" href="#Jutul.CoarseMesh"><code>Jutul.CoarseMesh</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CoarseMesh(G::JutulMesh, p)</code></pre><p>Construct a coarse mesh from a given <code>JutulMesh</code> that can be converted to an <code>UnstructuredMesh</code> instance. The second argument <code>p</code> should be a partition Vector with one entry per cell in the original grid that assigns that cell to a coarse block. Should be one-indexed and the numbering should be sequential and contain at least one fine cell for each coarse index. This is tested by the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/coarse.jl#L14-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.MRSTWrapMesh"><a class="docstring-binding" href="#Jutul.MRSTWrapMesh"><code>Jutul.MRSTWrapMesh</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MRSTWrapMesh(G, N = nothing)</code></pre><p>Mesh that adapts an exported MRST mesh to the Jutul interface. <code>G</code> is assumed to be read directly from file using <code>MAT.matread</code>. The raw exported grid can be found under the <code>data</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/mrst.jl#L9-L15">source</a></section></details></article><h2 id="Plotting-functions"><a class="docs-heading-anchor" href="#Plotting-functions">Plotting functions</a><a id="Plotting-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-functions" title="Permalink"></a></h2><p>Plotting requires that a Makie backend is loaded (typically GLMakie or CairoMakie). The documentation uses <code>CairoMakie</code> to work on machines without OpenGL enabled, but if you want fast and interactive plots, <code>GLMakie</code> should be preferred.</p><h3 id="Non-mutating"><a class="docs-heading-anchor" href="#Non-mutating">Non-mutating</a><a id="Non-mutating-1"></a><a class="docs-heading-anchor-permalink" href="#Non-mutating" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Jutul.plot_mesh"><a class="docstring-binding" href="#Jutul.plot_mesh"><code>Jutul.plot_mesh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_mesh(mesh)
plot_mesh(mesh;
    cells = nothing,
    faces = nothing,
    boundaryfaces = nothing,
    outer = false,
    color = :lightblue,
)</code></pre><p>Plot a <code>mesh</code> with uniform colors. Optionally, indices <code>cells</code>, <code>faces</code> or <code>boundaryfaces</code> can be passed to limit the plotting to a specific selection of entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/ext/makie_ext.jl#L33-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.plot_cell_data"><a class="docstring-binding" href="#Jutul.plot_cell_data"><code>Jutul.plot_cell_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_cell_data(mesh::JutulMesh, data::Vector; kwarg...)
plot_cell_data(mesh, data;
    cells = nothing,
    faces = nothing,
    boundaryfaces = nothing
)</code></pre><p>Plot cell-wise values (as a vector) on the mesh. Optionally, indices <code>cells</code>, <code>faces</code> or <code>boundaryfaces</code> can be passed to limit the plotting to a specific selection of entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/ext/makie_ext.jl#L102-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.plot_mesh_edges"><a class="docstring-binding" href="#Jutul.plot_mesh_edges"><code>Jutul.plot_mesh_edges</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_mesh_edges(mesh; kwarg...)</code></pre><p>Plot the edges of all cells on the exterior of a mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/ext/makie_ext.jl#L73-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.plot_interactive"><a class="docstring-binding" href="#Jutul.plot_interactive"><code>Jutul.plot_interactive</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_interactive(mesh, vector_of_dicts; kwarg...)</code></pre><p>Launch an interactive plot of a mesh with the given <code>vector_of_dicts</code> (or just a dict). Each dict can have cell data either as vectors (one value per cell) or matrices (one column per cell).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/ext/makie_ext.jl#L8-L14">source</a></section></details></article><h3 id="Mutating"><a class="docs-heading-anchor" href="#Mutating">Mutating</a><a id="Mutating-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Jutul.plot_mesh!"><a class="docstring-binding" href="#Jutul.plot_mesh!"><code>Jutul.plot_mesh!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_mesh!(ax, mesh)</code></pre><p>Mutating version of <code>plot_mesh</code> that plots into an existing Makie <code>Axis</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/ext/makie_ext.jl#L57-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.plot_cell_data!"><a class="docstring-binding" href="#Jutul.plot_cell_data!"><code>Jutul.plot_cell_data!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_cell_data!(ax, mesh, data; kwarg...)</code></pre><p>Mutating version of <code>plot_cell_data</code> that plots into an existing Makie <code>Axis</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/ext/makie_ext.jl#L123-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.plot_mesh_edges!"><a class="docstring-binding" href="#Jutul.plot_mesh_edges!"><code>Jutul.plot_mesh_edges!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_mesh_edges!(ax, mesh; kwarg...)</code></pre><p>Plot the edges of all cells on the exterior of a mesh into existing Makie <code>Axis</code> <code>ax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/ext/makie_ext.jl#L87-L92">source</a></section></details></article><h2 id="Example:-Cartesian-meshes"><a class="docs-heading-anchor" href="#Example:-Cartesian-meshes">Example: Cartesian meshes</a><a id="Example:-Cartesian-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Cartesian-meshes" title="Permalink"></a></h2><p>For example, we can make a small 2D mesh with given physical dimensions and convert it:</p><pre><code class="language-julia hljs">using Jutul
nx = 10
ny = 5
g2d_cart = CartesianMesh((nx, ny), (100.0, 50.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CartesianMesh (2D) with 10x5x1=50 cells</code></pre><pre><code class="language-julia hljs">g2d = UnstructuredMesh(g2d_cart)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnstructuredMesh with 50 cells, 85 faces and 30 boundary faces</code></pre><p>We can then plot it, colorizing each cell by its enumeration:</p><pre><code class="language-julia hljs">using CairoMakie
fig, ax, plt = plot_cell_data(g2d, 1:number_of_cells(g2d))
plot_mesh_edges!(ax, g2d)
fig</code></pre><img src="df84fc6b.png" alt="Example block output"/><p>If we want to drill down a bit further, we can make a plot:</p><p>We can make a 3D mesh in the same manner:</p><pre><code class="language-julia hljs">nz = 3
g3d = UnstructuredMesh(CartesianMesh((nx, ny, nz), (100.0, 50.0, 30.0)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnstructuredMesh with 150 cells, 355 faces and 190 boundary faces</code></pre><p>And plot it the same way:</p><pre><code class="language-julia hljs">using CairoMakie
nc = number_of_cells(g3d)
fig, ax, plt = plot_cell_data(g3d, 1:nc)
plot_mesh_edges!(ax, g3d)
fig</code></pre><img src="f6de0ec6.png" alt="Example block output"/><p>We can also plot only a subset of cells:</p><pre><code class="language-julia hljs">using CairoMakie
fig, ax, plt = plot_cell_data(g3d, 1:nc, cells = 1:2:nc)
fig</code></pre><img src="03e585a6.png" alt="Example block output"/><h2 id="Mesh-API-functions"><a class="docs-heading-anchor" href="#Mesh-API-functions">Mesh API functions</a><a id="Mesh-API-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-API-functions" title="Permalink"></a></h2><h3 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Jutul.number_of_cells"><a class="docstring-binding" href="#Jutul.number_of_cells"><code>Jutul.number_of_cells</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">number_of_cells(D::Union{DataDomain, DiscretizedDomain})</code></pre><p>Get the number of cells in a <code>DataDomain</code> or <code>DiscretizedDomain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/domains.jl#L60-L64">source</a></section><section><div><pre><code class="language-julia hljs">number_of_cells(g)::Integer</code></pre><p>Get the number of cells in a mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/meshes.jl#L143-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.number_of_faces"><a class="docstring-binding" href="#Jutul.number_of_faces"><code>Jutul.number_of_faces</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">number_of_faces(D::Union{DataDomain, DiscretizedDomain})</code></pre><p>Get the number of faces in a <code>DataDomain</code> or <code>DiscretizedDomain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/domains.jl#L69-L73">source</a></section><section><div><pre><code class="language-julia hljs">number_of_faces(g)::Integer</code></pre><p>Get the number of faces in a mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/meshes.jl#L150-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.number_of_boundary_faces"><a class="docstring-binding" href="#Jutul.number_of_boundary_faces"><code>Jutul.number_of_boundary_faces</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">number_of_boundary_faces(g)</code></pre><p>Get the number of boundary/exterior faces in a mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/meshes.jl#L157-L161">source</a></section></details></article><h3 id="Manipulation"><a class="docs-heading-anchor" href="#Manipulation">Manipulation</a><a id="Manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Jutul.extrude_mesh"><a class="docstring-binding" href="#Jutul.extrude_mesh"><code>Jutul.extrude_mesh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extrude_mesh(m2d::UnstructuredMesh, nlayers)
extrude_mesh(m2d::UnstructuredMesh, [1, 2, 5, 10])</code></pre><p>Extrude a 2D mesh into a 3D mesh by adding layers of cells in the z-direction. The number of layers can be specified as an integer or as an array of depths. The depths must be in increasing order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/extruded.jl#L2-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.extract_submesh"><a class="docstring-binding" href="#Jutul.extract_submesh"><code>Jutul.extract_submesh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_submesh(g::UnstructuredMesh, cells)</code></pre><p>Extract a subgrid for a given mesh and a iterable of <code>cells</code> to keep.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/unstructured/utils.jl#L27-L31">source</a></section></details></article><h2 id="Example:-Mesh-manipulation"><a class="docs-heading-anchor" href="#Example:-Mesh-manipulation">Example: Mesh manipulation</a><a id="Example:-Mesh-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Mesh-manipulation" title="Permalink"></a></h2><p>We can quickly build new meshes by applying transformations to an already existing mesh. Let us create a Cartesian mesh and extract the cells that lie within a circle:</p><pre><code class="language-julia hljs">using Jutul, CairoMakie
g = UnstructuredMesh(CartesianMesh((10, 10), (1.0, 1.0)))
geo = tpfv_geometry(g)
keep = Int[]
for c in 1:number_of_cells(g)
    x, y = geo.cell_centroids[:, c]
    if (x - 0.5)^2 + (y - 0.5)^2 &lt; 0.25
        push!(keep, c)
    end
end
subg = extract_submesh(g, keep)
fig, ax, plt = plot_mesh(subg)
plot_mesh_edges!(ax, g, color = :red)
fig</code></pre><img src="f451096d.png" alt="Example block output"/><p>We can turn this into a 3D mesh by extruding it, and then tweak the nodes:</p><pre><code class="language-julia hljs">g3d = Jutul.extrude_mesh(subg, 20)
for node in eachindex(subg.node_points)
    g3d.node_points[node] += 0.01*rand(3)
end
fig, ax, plt = plot_mesh(g3d)
fig</code></pre><img src="6ace1b68.png" alt="Example block output"/><h3 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Jutul.TwoPointFiniteVolumeGeometry"><a class="docstring-binding" href="#Jutul.TwoPointFiniteVolumeGeometry"><code>Jutul.TwoPointFiniteVolumeGeometry</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TwoPointFiniteVolumeGeometry(neighbors, areas, volumes, normals, cell_centers, face_centers)</code></pre><p>Store two-point geometry information for a given list of <code>neighbors</code> specified as a <code>2</code> by <code>n</code> matrix where <code>n</code> is the number of faces such that face <code>i</code> connectes cells <code>N[1, i]</code> and <code>N[2, i]</code>.</p><p>The two-point finite-volume geometry contains the minimal set of geometry information required to compute standard finite-volume discretizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/meshes.jl#L19-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.tpfv_geometry"><a class="docstring-binding" href="#Jutul.tpfv_geometry"><code>Jutul.tpfv_geometry</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tpfv_geometry(g)</code></pre><p>Generate two-point finite-volume geometry for a given grid, if supported.</p><p>See also <a href="#Jutul.TwoPointFiniteVolumeGeometry"><code>TwoPointFiniteVolumeGeometry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/meshes.jl#L10-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.find_enclosing_cells"><a class="docstring-binding" href="#Jutul.find_enclosing_cells"><code>Jutul.find_enclosing_cells</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_enclosing_cells(G, traj; geometry = tpfv_geometry(G), n = 25)</code></pre><p>Find the cell indices of cells in the mesh <code>G</code> that are intersected by a given trajectory <code>traj</code>. <code>traj</code> can be either a matrix with equal number of columns as dimensions in G (i.e. three columns for 3D) or a <code>Vector</code> of <code>SVector</code> instances with the same length.</p><p>The optional argument <code>geometry</code> is used to define the centroids and normals used in the calculations. You can precompute this if you need to perform many searches. The keyword argument <code>n</code> can be used to set the number of discretizations in each segment.</p><p><code>use_boundary</code> is by default set to <code>false</code>. If set to true, the boundary faces of cells are treated more rigorously when picking exactly what cells are cut by a trajectory, but this requires that the boundary normals are oriented outwards, which is currently not the case for all meshes from downstream packages.</p><p><code>atol</code> is the tolerance used when checking if points are inside the bounding box.</p><p><code>limit_box</code> speeds up the search by limiting the search to the minimal bounding box that contains both the trajectory and the mesh. This can be turned off by passing <code>false</code>. There should be no difference in the cells tagged by changing this option.</p><p><code>cells</code> can be used to limit the search to a subset of cells in the mesh. By default all cells are used. If <code>limit_box</code> is true, the function searches among the cells in intersect(cells, cells inside bounding box).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/trajectories.jl#L12-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Jutul.cells_inside_bounding_box"><a class="docstring-binding" href="#Jutul.cells_inside_bounding_box"><code>Jutul.cells_inside_bounding_box</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cells_inside_bounding_box(G::UnstructuredMesh, low_bb, high_bb; algorithm = :box, atol = 0.01)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/trajectories.jl#L260-L264">source</a></section></details></article><h2 id="Example:-Cell-intersection"><a class="docs-heading-anchor" href="#Example:-Cell-intersection">Example: Cell intersection</a><a id="Example:-Cell-intersection-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Cell-intersection" title="Permalink"></a></h2><pre><code class="language-julia hljs">using CairoMakie, Jutul
# 3D mesh
G = CartesianMesh((4, 4, 5), (100.0, 100.0, 100.0))
trajectory = [
    50.0 25.0 1;
    55 35.0 25;
    65.0 40.0 50.0;
    70.0 70.0 90.0
]

cells = Jutul.find_enclosing_cells(G, trajectory)

# Optional plotting, requires Makie:
fig, ax, plt = Jutul.plot_mesh_edges(G)
plot_mesh!(ax, G, cells = cells, alpha = 0.5, transparency = true)
lines!(ax, trajectory, linewidth = 10)
fig</code></pre><img src="7a89e227.png" alt="Example block output"/><p>2D version:</p><pre><code class="language-julia hljs">using CairoMakie, Jutul
# 2D mesh
G = CartesianMesh((50, 50), (1.0, 2.0))
trajectory = [
    0.1 0.1;
    0.2 0.4;
    0.3 1.2
]
fig, ax, plt = Jutul.plot_mesh_edges(G)
cells = Jutul.find_enclosing_cells(G, trajectory)
# Plotting, needs Makie
fig, ax, plt = Jutul.plot_mesh_edges(G)
plot_mesh!(ax, G, cells = cells, alpha = 0.5, transparency = true)
lines!(ax, trajectory[:, 1], trajectory[:, 2], linewidth = 3)
fig</code></pre><img src="a55761c5.png" alt="Example block output"/><h2 id="Mesh-generation"><a class="docs-heading-anchor" href="#Mesh-generation">Mesh generation</a><a id="Mesh-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-generation" title="Permalink"></a></h2><h3 id="Gmsh-support"><a class="docs-heading-anchor" href="#Gmsh-support">Gmsh support</a><a id="Gmsh-support-1"></a><a class="docs-heading-anchor-permalink" href="#Gmsh-support" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Jutul.mesh_from_gmsh"><a class="docstring-binding" href="#Jutul.mesh_from_gmsh"><code>Jutul.mesh_from_gmsh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">G = mesh_from_gmsh(pth)
G = mesh_from_gmsh()
G = mesh_from_gmsh(pth; verbose = true)</code></pre><p>Parse a Gmsh file and return a Jutul <code>UnstructuredMesh</code> (in 3D only). Requires the Gmsh.jl package to be loaded. If no path is provided in <code>pth</code> it is assumed that you are managing the Gmsh state manually and it will use the current selected mesh inside Gmsh. Please note that Gmsh is GPL licensed unless you have obtained another type of license from the authors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/ext/gmsh_ext.jl#L3-L13">source</a></section></details></article><h3 id="Radial-mesh"><a class="docs-heading-anchor" href="#Radial-mesh">Radial mesh</a><a id="Radial-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-mesh" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Jutul, CairoMakie
import Jutul.RadialMeshes: radial_mesh
import Jutul: plot_mesh_edges
nangle = 10
radii = [0.2, 0.5, 1.0]
m = radial_mesh(nangle, radii; centerpoint = true)
plot_mesh_edges(m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Scene(1 children, 0 plots), Makie.Axis3 (13 plots), Makie.LineSegments{Tuple{Base.ReinterpretArray{GeometryBasics.Point{2, Float64}, 1, Tuple{StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}, Vector{Tuple{StaticArraysCore.SVector{2, Float64}, StaticArraysCore.SVector{2, Float64}}}, false}}})</code></pre><p>Radial meshes can still be indexed as Cartesian meshes:</p><pre><code class="language-julia hljs">IJ = map(i -&gt; cell_ijk(m, i), 1:number_of_cells(m))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">30-element Vector{Tuple{Int64, Int64, Int64}}:
 (1, 1, 1)
 (2, 1, 1)
 (3, 1, 1)
 (4, 1, 1)
 (5, 1, 1)
 (6, 1, 1)
 (7, 1, 1)
 (8, 1, 1)
 (9, 1, 1)
 (10, 1, 1)
 ⋮
 (2, 3, 1)
 (3, 3, 1)
 (4, 3, 1)
 (5, 3, 1)
 (6, 3, 1)
 (7, 3, 1)
 (8, 3, 1)
 (9, 3, 1)
 (10, 3, 1)</code></pre><pre><code class="language-julia hljs">fig, ax, plt = plot_cell_data(m, map(first, IJ))
fig</code></pre><img src="09281d13.png" alt="Example block output"/><pre><code class="language-julia hljs">fig, ax, plt = plot_cell_data(m, map(ijk -&gt; ijk[2], IJ))
fig</code></pre><img src="1bcbbdb1.png" alt="Example block output"/><p>We can also plot the faces by using the nodes together with standard Makie plotting calls. We regenerate the mesh and make it contain a single cell in the middle before plotting it:</p><pre><code class="language-julia hljs">m = radial_mesh(nangle, radii; centerpoint = false)
ncells = number_of_cells(m)
fig, ax, plt = plot_cell_data(m, 1:ncells, alpha = 0.25)
scatter!(ax, m.node_points)
for face in 1:number_of_faces(m)
    n1, n2 = m.faces.faces_to_nodes[face]
    pt1 = m.node_points[n1]
    pt2 = m.node_points[n2]
    lines!(ax, [pt1, pt2], color = :red)
end

for bface in 1:number_of_boundary_faces(m)
    n1, n2 = m.boundary_faces.faces_to_nodes[bface]
    pt1 = m.node_points[n1]
    pt2 = m.node_points[n2]
    lines!(ax, [pt1, pt2], color = :blue)
end
fig</code></pre><img src="9a7a228e.png" alt="Example block output"/><p>We can also zoom in on a single cell and plot the oriented normals:</p><pre><code class="language-julia hljs">using LinearAlgebra
geo = tpfv_geometry(m)
cellno = 1
fig, ax, plt = plot_mesh(m, cells = cellno)
for face in m.faces.cells_to_faces[cellno]
    n1, n2 = m.faces.faces_to_nodes[face]
    @info &quot;Interior edge $n1 to $n2&quot;
    pt1 = m.node_points[n1]
    pt2 = m.node_points[n2]
    lines!(ax, [pt1, pt2], color = :red)
    midpt = (pt1 + pt2) / 2
    if m.faces.neighbors[face][1] == cellno
        sgn = 1
    else
        sgn = -1
    end
    lines!(ax, [midpt, midpt + sgn*norm(pt2 - pt1, 2)*geo.normals[:, face]], color = :orange)
end
for bface in m.boundary_faces.cells_to_faces[cellno]
    n1, n2 = m.boundary_faces.faces_to_nodes[bface]
    @info &quot;Exterior edge $n1 to $n2&quot;
    pt1 = m.node_points[n1]
    pt2 = m.node_points[n2]
    lines!(ax, [pt1, pt2], color = :blue)
    midpt = (pt1 + pt2) / 2
    lines!(ax, [midpt, midpt + norm(pt2 - pt1, 2)*geo.boundary_normals[:, bface]], color = :green)
end
scatter!(ax, m.node_points)
fig</code></pre><img src="9a60163d.png" alt="Example block output"/><h3 id="Spiral-meshes"><a class="docs-heading-anchor" href="#Spiral-meshes">Spiral meshes</a><a id="Spiral-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Spiral-meshes" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Jutul.RadialMeshes.spiral_mesh"><a class="docstring-binding" href="#Jutul.RadialMeshes.spiral_mesh"><code>Jutul.RadialMeshes.spiral_mesh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mesh = spiral_mesh(10, 3, spacing = [0.0, 0.5, 1.0])</code></pre><p>Spiral mesh generator. Generates a spiral mesh in 2D with an optional &quot;spacing&quot; subdiscretization between each segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/RadialMeshes/spiral.jl#L1-L6">source</a></section></details></article><pre><code class="language-julia hljs">using Jutul, CairoMakie
import Jutul.RadialMeshes: spiral_mesh
n_angular_sections = 10
nrotations = 4
spacing = [0.0, 0.5, 1.0]
rmesh = spiral_mesh(n_angular_sections, nrotations, spacing = spacing)
num_cells = number_of_cells(rmesh)

fig, ax, plt = plot_cell_data(rmesh, 1:number_of_cells(rmesh))
fig</code></pre><img src="26e4060a.png" alt="Example block output"/><article><details class="docstring" open="true"><summary id="Jutul.RadialMeshes.spiral_mesh_tags"><a class="docstring-binding" href="#Jutul.RadialMeshes.spiral_mesh_tags"><code>Jutul.RadialMeshes.spiral_mesh_tags</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spiral_mesh_tags(rmesh, spacing = missing)</code></pre><p>Get the tags for a spiral mesh. If spacing is provided, it will also return the spacing and winding tags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/Jutul.jl/blob/0ad5c7cf8914d94c0cc1f43c7c7bd8a57e6cfa22/src/meshes/RadialMeshes/utils.jl#L1-L6">source</a></section></details></article><pre><code class="language-julia hljs">import Jutul.RadialMeshes: spiral_mesh_tags
tags = spiral_mesh_tags(rmesh, spacing)
fig = Figure(size = (400, 1800))
for (figno, pp) in enumerate(pairs(tags))
    k, val = pp
    ax = Axis(fig[figno, 1], title = &quot;Spiral tag $k&quot;)
    plot_cell_data!(ax, rmesh, val)
end
fig</code></pre><img src="dd08ac55.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization/">« Sensitivities, adjoints and optimization</a><a class="docs-footer-nextpage" href="../units/">Units »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Thursday 26 February 2026 10:51">Thursday 26 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
