var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Jutul","category":"page"},{"location":"#Jutul","page":"Home","title":"Jutul","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Jutul.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Jutul]","category":"page"},{"location":"#Jutul.AMGPreconditioner","page":"Home","title":"Jutul.AMGPreconditioner","text":"AMG on CPU (Julia native)\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.BlockMajorLayout","page":"Home","title":"Jutul.BlockMajorLayout","text":"Same as EntityMajorLayout, but the nzval is a matrix\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.CartesianMesh","page":"Home","title":"Jutul.CartesianMesh","text":"CartesianMesh(dims, [Δ, [origin]])\n\nCreate a Cartesian mesh with dimensions specified by the Tuple dims.\n\nArguments\n\ndims::Tuple: Number of grid cells in each direction. For example, (nx, ny) will give a 2D grids with nx cells in the x-direction.\nΔ::Tuple=ones(length(dims)): Equal length to dims. First option: A Tuple of scalars where each entry is the length of each cell in that direction. For\n\nexample, specifying (Δx, Δy) for a uniform grid with each grid cell having area ofΔx*Δy. Second option: ATuple` of vectors where each entry contains the cell sizes in the direction.\n\norigin=zeros(length(dims)): The origin of the first corner in the grid.\n\nExamples\n\nGenerate a uniform 3D mesh that discretizes a domain of 2 by 3 by 5 units with 3 by 5 by 2 cells:\n\njulia> CartesianMesh((3, 5, 2), (2.0, 3.0, 5.0))\nCartesianMesh (3D) with 3x5x2=30 cells\n\nGenerate a non-uniform 2D mesh:\n\njulia> CartesianMesh((2, 3), ([1.0, 2.0], [0.1, 3.0, 2.5]))\nCartesianMesh (3D) with 3x5x2=30 cells\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.CompactAutoDiffCache","page":"Home","title":"Jutul.CompactAutoDiffCache","text":"Cache that holds an AD vector/matrix together with their positions.\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.ConstantVariables","page":"Home","title":"Jutul.ConstantVariables","text":"A set of constants, repeated over the entire set of Cells or some other entity\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.DampedJacobiPreconditioner","page":"Home","title":"Jutul.DampedJacobiPreconditioner","text":"Damped Jacobi preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.DefaultContext","page":"Home","title":"Jutul.DefaultContext","text":"Default context\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.EntityMajorLayout","page":"Home","title":"Jutul.EntityMajorLayout","text":"Domain entities sequentially in rows:\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.EquationMajorLayout","page":"Home","title":"Jutul.EquationMajorLayout","text":"Equations are stored sequentially in rows, derivatives of same type in columns:\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.EquationSet","page":"Home","title":"Jutul.EquationSet","text":"Set of a variable where equations are defined\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.FlowDiscretization","page":"Home","title":"Jutul.FlowDiscretization","text":"Discretization of kgradp + upwind\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.GlobalSet","page":"Home","title":"Jutul.GlobalSet","text":"The global set of variables\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.GroupWisePreconditioner","page":"Home","title":"Jutul.GroupWisePreconditioner","text":"Multi-model preconditioners\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.ILUZeroPreconditioner","page":"Home","title":"Jutul.ILUZeroPreconditioner","text":"ILU(0) preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.JutulAutoDiffCache","page":"Home","title":"Jutul.JutulAutoDiffCache","text":"An AutoDiffCache is a type that holds both a set of AD values and a map into some global Jacobian.\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.JutulDiscretization","page":"Home","title":"Jutul.JutulDiscretization","text":"Ask discretization for entry i for specific entity\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.LUPreconditioner","page":"Home","title":"Jutul.LUPreconditioner","text":"Full LU factorization as preconditioner (intended for smaller subsystems)\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.ParallelCSRContext","page":"Home","title":"Jutul.ParallelCSRContext","text":"Context that uses threads etc to accelerate loops\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.SPU","page":"Home","title":"Jutul.SPU","text":"Single-point upwinding.\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.TPFA","page":"Home","title":"Jutul.TPFA","text":"Two-point flux approximation.\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.TwoPointFiniteVolumeGeometry","page":"Home","title":"Jutul.TwoPointFiniteVolumeGeometry","text":"TwoPointFiniteVolumeGeometry(neighbors, areas, volumes, normals, cell_centers, face_centers)\n\nStore two-point geometry information for a given list of neighbors specified as a 2 by n matrix where n is the number of faces such that face i connectes cells N[1, i] and N[2, i].\n\nThe two-point finite-volume geometry contains the minimal set of geometry information required to compute standard finite-volume discretizations.\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.VariableSet","page":"Home","title":"Jutul.VariableSet","text":"Set of a variable where variables are defined\n\n\n\n\n\n","category":"type"},{"location":"#Jutul.absolute_increment_limit-Tuple{JutulVariables}","page":"Home","title":"Jutul.absolute_increment_limit","text":"Absolute allowable change for variable during a nonlinear update.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.align_to_jacobian!-NTuple{4, Any}","page":"Home","title":"Jutul.align_to_jacobian!","text":"Update an equation so that it knows where to store its derivatives in the Jacobian representation.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.align_to_jacobian!-Tuple{ConservationLawTPFAStorage, ConservationLaw, Any, Any, Cells}","page":"Home","title":"Jutul.align_to_jacobian!","text":"Update positions of law's derivatives in global Jacobian\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.allocate_array_ad-Tuple{AbstractMatrix}","page":"Home","title":"Jutul.allocate_array_ad","text":"allocate_array_ad(v::AbstractMatrix, ...)\n\nConvert matrix to AD matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.allocate_array_ad-Tuple{AbstractVector}","page":"Home","title":"Jutul.allocate_array_ad","text":"allocate_array_ad(v::AbstractVector, ...)\n\nConvert vector to AD vector.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.allocate_array_ad-Union{Tuple{Vararg{R}}, Tuple{R}} where R<:Integer","page":"Home","title":"Jutul.allocate_array_ad","text":"allocate_array_ad(n[, m]; <keyword arguments>)\n\nAllocate vector or matrix as AD with optionally provided context and a specified non-zero on the diagonal.\n\nArguments\n\nn::Integer: number of entries in vector, or number of rows if m is given.\nm::Integer: number of rows (optional)\n\nKeyword arguments\n\nnpartials = 1: Number of partials derivatives to allocate for each element\ndiag_pos = nothing: Indices of where to put entities on the diagonal (if any)\n\nOther keyword arguments are passed onto get_ad_entity_scalar.\n\nExamples:\n\nAllocate a vector with a single partial:\n\njulia> allocate_array_ad(2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 1}}:\n Dual{nothing}(0.0,0.0)\n Dual{nothing}(0.0,0.0)\n\nAllocate a vector with two partials, and set the first to one:\n\njulia> allocate_array_ad(2, diag_pos = 1, npartials = 2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,1.0,0.0)\n\nSet up a matrix with two partials, where the first column has partials [1, 0] and the second [0, 1]:\n\njulia> allocate_array_ad(2, 2, diag_pos = [1, 2], npartials = 2)\n2×2 Matrix{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)  Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,0.0,1.0)  Dual{nothing}(0.0,0.0,1.0)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.apply_forces!-NTuple{4, Any}","page":"Home","title":"Jutul.apply_forces!","text":"Apply a set of forces to all equations. Equations that don't support a given force will just ignore them, thanks to the power of multiple dispatch.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.apply_forces_to_equation!-NTuple{7, Any}","page":"Home","title":"Jutul.apply_forces_to_equation!","text":"apply_forces_to_equation!(diag_part, storage, model, eq, eq_s, force, time)\n\nUpdate an equation with the effect of a force. The default behavior for any force we do not know about is to assume that the force does not impact this particular equation.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.as_value-Union{Tuple{AbstractArray{D}}, Tuple{D}} where D<:ForwardDiff.Dual","page":"Home","title":"Jutul.as_value","text":"Create a mapped array that produces only the values when indexed.\n\nOnly useful for AD arrays, otherwise it does nothing.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.associated_entity-Tuple{JutulEquation}","page":"Home","title":"Jutul.associated_entity","text":"Return the domain entity the equation is associated with\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.associated_entity-Tuple{JutulVariables}","page":"Home","title":"Jutul.associated_entity","text":"The entity a variable is associated with, and can hold partial derivatives with respect to.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.cell_dims-Tuple{Any, Any}","page":"Home","title":"Jutul.cell_dims","text":"cell_dims(g, pos)::Tuple\n\nGet physical cell dimensions of cell with index pos for grid g.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.cell_index-Tuple{Any, Tuple}","page":"Home","title":"Jutul.cell_index","text":"cell_index(g, pos)\n\nGet linear (scalar) index of mesh cell from provided IJK tuple pos.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.convergence_criterion-Tuple{Any, Any, JutulEquation, Any, Any}","page":"Home","title":"Jutul.convergence_criterion","text":"convergence_criterion(model, storage, eq, eq_s, r; dt = 1)\n\nGet the convergence criterion values for a given equation. Can be checked against the corresponding tolerances.\n\nArguments\n\nmodel: model that generated the current equation.\nstorage: global simulator storage.\neq::JutulEquation: equation implementation currently being checked\neq_s: storage for eq where values are contained.\nr: the local residual part corresponding to this model, as a matrix with column index equaling entity index\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.convert_state_ad","page":"Home","title":"Jutul.convert_state_ad","text":"Convert a state containing variables as arrays of doubles to a state where those arrays contain the same value as Dual types. The dual type is currently taken from ForwardDiff.\n\n\n\n\n\n","category":"function"},{"location":"#Jutul.coord_offset-Tuple{Any, AbstractFloat}","page":"Home","title":"Jutul.coord_offset","text":"Lower corner for one dimension, without any transforms applied\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.declare_pattern-Tuple{Any, Any, Any, Any, Vararg{Any}}","page":"Home","title":"Jutul.declare_pattern","text":"Give out source, target arrays of equal length for a given equation attached to the given model.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.declare_sparsity","page":"Home","title":"Jutul.declare_sparsity","text":"Give out I, J arrays of equal length for a given equation attached to the given model.\n\n\n\n\n\n","category":"function"},{"location":"#Jutul.degrees_of_freedom_per_entity-Tuple{Any, ConstantVariables}","page":"Home","title":"Jutul.degrees_of_freedom_per_entity","text":"Constant variables hold no degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.degrees_of_freedom_per_entity-Tuple{Any, ScalarVariable}","page":"Home","title":"Jutul.degrees_of_freedom_per_entity","text":"Number of independent primary variables / degrees of freedom per computational entity.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.dim-Tuple{AbstractJutulMesh}","page":"Home","title":"Jutul.dim","text":"dim(g)::Integer\n\nGet the dimension of a mesh.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.full_cell-Tuple{Any, Any}","page":"Home","title":"Jutul.full_cell","text":"Inner cell to local cell (full set)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_1d_interpolator-Tuple{Any, Any}","page":"Home","title":"Jutul.get_1d_interpolator","text":"get_1d_interpolator(xs, ys; <keyword arguments>)\n\nGet a 1D interpolator F(x) ≈ y for a table xs, ys that by default does constant extrapolation\n\nArguments\n\nxs: sorted list of parameter points.\nys: list of function values with equal length to xs\nmethod=LinearInterpolant: constructor for the interpolation. Defaults to LinearInterpolant which does simple linear interpolation.\ncap_endpoints = true: Add values so that the endpoints are capped (constant extrapolation). Otherwise, the extrapolation will match the method.\ncap_start = cap_endpoints: Fine-grained version of cap_endpoints for the start of the interval only (extrapolation for x < xs[1])\ncap_end = cap_endpoints:Fine-grained version of cap_endpoints for the end of the interval only (extrapolation for x > xs[end])\n\nExamples\n\nx = collect(0:0.1:4)\nI = get_1d_interpolator(x, sin.(x))\nisapprox(I(π/2), 1.0, atol = 1e-2)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_ad_entity_scalar-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real","page":"Home","title":"Jutul.get_ad_entity_scalar","text":"get_ad_entity_scalar(v::Real, npartials, diag_pos = nothing; <keyword_arguments>)\n\nGet scalar with partial derivatives as AD instance.\n\nArguments\n\nv::Real: Value of AD variable.\nnpartials: Number of partial derivatives each AD instance holds.\ndiag_pos = nothing: Position(s) of where to set 1 as the partial derivative instead of zero.\n\nKeyword arguments\n\ntag = nothing: Tag for AD instance. Two AD values of the different tag cannot interoperate to avoid perturbation confusion (see ForwardDiff documentation).\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_dependencies-Tuple{Any, Any}","page":"Home","title":"Jutul.get_dependencies","text":"Get dependencies of variable when viewed as a secondary variable. Normally autogenerated with @jutul_secondary\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_diagonal_entries-Tuple{JutulEquation, Any}","page":"Home","title":"Jutul.get_diagonal_entries","text":"get_diagonal_entries(eq::JutulEquation, eq_s)\n\nGet the diagonal entries of a cache, i.e. the entries where entity type and index equals that of the governing equation.\n\nNote: Be very careful about modifications to this array, as this is a view into the internal AD buffers and it is very easy to create inconsistent Jacobians.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_entity_tag-Tuple{Any, Any}","page":"Home","title":"Jutul.get_entity_tag","text":"get_entity_tag(basetag, entity)\n\nCombine a base tag (which can be nothing) with a entity to get a tag that captures base tag + entity tag for use with AD initialization.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_entries-Tuple{CompactAutoDiffCache}","page":"Home","title":"Jutul.get_entries","text":"Get entries of autodiff cache. Entries are AD vectors that hold values and derivatives.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_entries-Tuple{JutulEquation}","page":"Home","title":"Jutul.get_entries","text":"Get the entries of the main autodiff cache for an equation.\n\nNote: This only gets the .equation field's entries.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_parameters-Tuple{SimulationModel}","page":"Home","title":"Jutul.get_parameters","text":"get_parameters(model::SimulationModel)\n\nGet the parameter definitions (as OrderedDict) for a given model.\n\nParameters are defined as static values in a forward simulation that combine with the primary variables to compute secondary variables and model equations.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_primary_variable_ordered_entities-Tuple{SimulationModel}","page":"Home","title":"Jutul.get_primary_variable_ordered_entities","text":"get_primary_variable_ordered_entities(model::SimulationModel)\n\nGet only the entities where primary variables are present, sorted by their order in the primary variables.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_primary_variables-Tuple{SimulationModel}","page":"Home","title":"Jutul.get_primary_variables","text":"get_primary_variables(model::SimulationModel)\n\nGet the primary variable definitions (as OrderedDict) for a given model.\n\nPrimary variables are sometimes referred to as solution variables or primary unknowns. The set of primary variables completely determines the state of the system together with the parameters.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_secondary_variables-Tuple{SimulationModel}","page":"Home","title":"Jutul.get_secondary_variables","text":"get_secondary_variables(model::SimulationModel)\n\nGet the secondary variable definitions (as OrderedDict) for a given model.\n\nSecondary variables are variables that can be computed from the primary variables together with the parameters.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_sparse_arguments-Tuple{Any, Any}","page":"Home","title":"Jutul.get_sparse_arguments","text":"get_sparse_arguments(storage, model)\n\nGet the [SparsePattern]@ref for the Jacobian matrix of a given simulator storage and corresponding model.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.get_variables-Tuple{SimulationModel}","page":"Home","title":"Jutul.get_variables","text":"get_variables(model::SimulationModel)\n\nGet all variable definitions (as OrderedDict) for a given model.\n\nThis is the union of get_secondary_variables and get_primary_variables.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.global_cell-Tuple{Any, Any}","page":"Home","title":"Jutul.global_cell","text":"Local cell -> global cell (full set)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.global_face-Tuple{Any, Any}","page":"Home","title":"Jutul.global_face","text":"Local face -> global face (full set)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.initialize_context!-NTuple{4, Any}","page":"Home","title":"Jutul.initialize_context!","text":"Initialize context when setting up a model\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.initialize_extra_state_fields!-Tuple{Any, JutulModel}","page":"Home","title":"Jutul.initialize_extra_state_fields!","text":"initialize_extra_state_fields!(state, model::JutulModel)\n\nAdd model-dependent changing variables that need to be in state, but are never AD variables themselves (for example status flags).\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.initialize_storage!-Tuple{Any, JutulModel}","page":"Home","title":"Jutul.initialize_storage!","text":"initialize_storage!(storage, model::JutulModel; initialize_state0 = true)\n\nInitialize the already allocated storage at the beginning of a simulation. Use this to e.g. set up extra stuff in state0 needed for initializing the simulation loop.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.initialize_variable_value!-Tuple{Any, Any, GroupedVariables, Symbol, AbstractVector}","page":"Home","title":"Jutul.initialize_variable_value!","text":"Initializer for the value of non-scalar primary variables\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.interior_cell-Tuple{Any, Any}","page":"Home","title":"Jutul.interior_cell","text":"Local cell in full set -> inner cell (or zero)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.local_ad-Tuple{Any, Any, Any}","page":"Home","title":"Jutul.local_ad","text":"local_ad(state::T, index::I, ad_tag::∂T) where {T, I<:Integer, ∂T}\n\nCreate localad for state for index I of AD tag of type adtag\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.local_cell-Tuple{Any, Any}","page":"Home","title":"Jutul.local_cell","text":"Global cell -> local cell (full set)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.local_face-Tuple{Any, Any}","page":"Home","title":"Jutul.local_face","text":"Global face -> local face (full set)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.local_residual_view-NTuple{4, Any}","page":"Home","title":"Jutul.local_residual_view","text":"local_residual_view(r_buf, model, eq, equation_offset)\n\nGet a matrix view of the residual so that, independent of ordering, the column index corresponds to the entity index for the given equation eq starting at equation_offset in the global residual buffer r_buf.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.maximum_value-Tuple{JutulVariables}","page":"Home","title":"Jutul.maximum_value","text":"Upper (inclusive) limit for variable.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.minimum_value-Tuple{JutulVariables}","page":"Home","title":"Jutul.minimum_value","text":"Lower (inclusive) limit for variable.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_cells-Tuple{AbstractJutulMesh}","page":"Home","title":"Jutul.number_of_cells","text":"number_of_cells(g)::Integer\n\nGet the number of cells in a mesh.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_degrees_of_freedom-Tuple{JutulModel}","page":"Home","title":"Jutul.number_of_degrees_of_freedom","text":"Total number of degrees of freedom for a model, over all primary variables and all entities.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_entities-Tuple{Any, JutulEquation}","page":"Home","title":"Jutul.number_of_entities","text":"Get the number of entities (e.g. the number of cells) that the equation is defined on.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_entities-Tuple{Any, JutulVariables}","page":"Home","title":"Jutul.number_of_entities","text":"Number of entities (e.g. Cells, Faces) a variable is defined on. By default, each primary variable exists on all cells of a discretized domain\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_entities-Tuple{JutulAutoDiffCache}","page":"Home","title":"Jutul.number_of_entities","text":"Get number of entities a cache is defined on.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_entities-Tuple{T} where T<:(AbstractVector)","page":"Home","title":"Jutul.number_of_entities","text":"Number of entities for vector stored in state (just the number of elements)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_entities-Tuple{T} where T<:AbstractArray","page":"Home","title":"Jutul.number_of_entities","text":"Number of entities for matrix stored in state (convention is number of columns)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_equations-Tuple{Any, JutulEquation}","page":"Home","title":"Jutul.number_of_equations","text":"Get the total number of equations on the domain of model.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_equations_per_entity-Tuple{JutulModel, JutulEquation}","page":"Home","title":"Jutul.number_of_equations_per_entity","text":"Get the number of equations per entity. For example, mass balance of two components will have two equations per grid cell (= entity)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_faces-Tuple{Any}","page":"Home","title":"Jutul.number_of_faces","text":"number_of_faces(g)::Integer\n\nGet the number of faces in a mesh.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_partials_per_entity-Tuple{JutulEquation}","page":"Home","title":"Jutul.number_of_partials_per_entity","text":"Get the number of partials\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_partials_per_entity-Tuple{SimulationModel, JutulEntity}","page":"Home","title":"Jutul.number_of_partials_per_entity","text":"number_of_partials_per_entity(model::SimulationModel, entity::JutulEntity)\n\nGet the number of local partial derivatives per entity in a model for a given JutulEntity. This is the sum of degrees_of_freedom_per_entity for all primary variables defined on entity.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.number_of_values","page":"Home","title":"Jutul.number_of_values","text":"Total number of values for a model, for a given type of variables over all entities\n\n\n\n\n\n","category":"function"},{"location":"#Jutul.read_results-Tuple{Any}","page":"Home","title":"Jutul.read_results","text":"Read results from a given outputpath provded to simulate or simulatorconfig\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.relative_increment_limit-Tuple{JutulVariables}","page":"Home","title":"Jutul.relative_increment_limit","text":"Relative allowable change for variable during a nonlinear update. A variable with value |x| and relative limit 0.2 cannot change more than |x|*0.2.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.replace_variables!-Tuple{Any}","page":"Home","title":"Jutul.replace_variables!","text":"replace_variables!(model, throw = true, varname = vardef, varname2 = vardef2)\n\nReplace one or more variables that already exists (either primary or secondary).\n\nArguments\n\nmodel: instance where variables is to be replaced\nvarname=vardef::JutulVariables: replace variable with varname by vardef\nthrow=true: throw an error if the named variable definition is not found in primary or secondary, otherwise silently return\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.set_default_tolerances-Tuple{Any}","page":"Home","title":"Jutul.set_default_tolerances","text":"set_default_tolerances(model)\n\nSet default tolerances for the nonlinear convergence check of the governing equations.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.set_parameters!-Tuple{Any}","page":"Home","title":"Jutul.set_parameters!","text":"set_parameters!(model, parname = pardef)\n\nSet a parameter with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.set_primary_variables!-Tuple{Any}","page":"Home","title":"Jutul.set_primary_variables!","text":"set_primary_variables!(model, varname = vardef)\nset_primary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a primary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.set_secondary_variables!-Tuple{Any}","page":"Home","title":"Jutul.set_secondary_variables!","text":"set_secondary_variables!(model, varname = vardef)\nset_secondary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a secondary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.setup_adjoint_storage-Tuple{Any}","page":"Home","title":"Jutul.setup_adjoint_storage","text":"setup_adjoint_storage(model; state0 = setup_state(model), parameters = setup_parameters(model))\n\nSet up storage for use with solve_adjoint_sensitivities!.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.setup_parameters-Tuple{JutulModel}","page":"Home","title":"Jutul.setup_parameters","text":"setup_parameters(model::JutulModel; name = value)\n\nSet up a parameter storage for a given model with values for the parameter defined in the model.\n\nArguments\n\nname=value: The name of the parameter together with the value(s) of the parameter.\n\nA scalar (or short vector of the right size for GroupedVariables) will be repeated over the entire domain, while a vector (or matrix for GroupedVariables) with length (number of columns for GroupedVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.setup_state!","page":"Home","title":"Jutul.setup_state!","text":"setup_state!(state, model::JutulModel, init_values::AbstractDict = Dict())\n\nInitialize primary variables and other state fields, given initial values as a Dict\n\n\n\n\n\n","category":"function"},{"location":"#Jutul.setup_state-Tuple{JutulModel, Vararg{Any}}","page":"Home","title":"Jutul.setup_state","text":"setup_state(model::JutulModel, name1 = value1, name2 = value2)\n\nSet up a state for a given model with values for the primary variables defined in the model. Normally all primary variables must be initialized in this way.\n\nArguments\n\nname=value: The name of the primary variable together with the value(s) used to initialize the primary variable.\n\nA scalar (or short vector of the right size for GroupedVariables) will be repeated over the entire domain, while a vector (or matrix for GroupedVariables) with length (number of columns for GroupedVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\nNote: You likely want to overload [setup_state!]@ref for a custom model instead of setup_state\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.setup_storage!-Tuple{Any, JutulModel}","page":"Home","title":"Jutul.setup_storage!","text":"setup_storage!(storage, model::JutulModel; setup_linearized_system = true,\n                                                setup_equations = true,\n                                                state0 = setup_state(model),\n                                                parameters = setup_parameters(model),\n                                                tag = nothing,\n                                                state0_ad = false,\n                                                state_ad = true,\n                                                kwarg...)\n\nAllocate storage for a given model. The storage consists of all dynamic quantities used in the simulation. The default implementation allocates properties, equations and linearized system.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.setup_storage-Tuple{JutulModel}","page":"Home","title":"Jutul.setup_storage","text":"setup_storage(model::JutulModel; kwarg...)\n\nAllocate storage for the model. You should overload setup_storage! if you have a custom definition.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}","page":"Home","title":"Jutul.simulate!","text":"simulate!(sim::JutulSimulator, timesteps::AbstractVector; forces = nothing,\n                                                               config = nothing,\n                                                               initialize = true,\n                                                               restart = nothing,\n                                                               state0 = nothing,\n                                                               parameters = nothing,\n                                                               kwarg...)\n\nNon-allocating (or perhaps less allocating) version of simulate!.\n\nArguments\n\ninitialize=true: Perform internal updates as if this is the first time \n\nSee also simulate for additional supported input arguments.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}","page":"Home","title":"Jutul.simulate","text":"simulate(state0, model, timesteps, parameters = setup_parameters(model))\nsimulate(state0, model, timesteps, info_level = 3)\nsimulate(state0, model, timesteps; <keyword arguments>)\n\nSimulate a set of timesteps with model for the given initial state0 and optionally specific parameters. Additional keyword arguments are passed onto simulator_config and simulate!. This interface is primarily for convenience, as all storage for the simulator is allocated upon use and discared upon return. If you want to perform multiple simulations with the same model it is advised to instead instantiate Simulator  and combine it with simulate!.\n\nArguments\n\nstate0::Dict: initial state, typically created using setup_state for the model in use.\nmodel::JutulModel: model that describes the discretized system to solve, for example SimulationModel or MultiModel.\ntimesteps::AbstractVector: Vector of desired report steps. The simulator will perform time integration until sum(timesteps)  is reached, providing outputs at the end of each report step.\nparameters=setup_parameters(model): Optional overrides the default parameters for the model.\nforces=nothing: Either nothing (for no forces), a single set of forces from setup_forces(model) or a Vector of such forces with equal length to timesteps.\nrestart=nothing: If an integer is provided, the simulation will attempt to restart from that step. Requires that output_path is provided here or in the config.\nconfig=simulator_config(model): Configuration Dict that holds many fine grained settings for output, linear solver, time-steps, outputs etc.\n\nAdditional arguments are passed onto simulator_config.\n\nSee also simulate!, Simulator, SimulationModel, simulator_config.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.simulate-Tuple{Any, JutulSimulator, AbstractVector}","page":"Home","title":"Jutul.simulate","text":"simulate(state0, sim::JutulSimulator, timesteps::AbstractVector; parameters = nothing, kwarg...)\n\nSimulate a set of timesteps with simulator for the given initial state0 and optionally specific parameters.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.solve_adjoint_sensitivities!-NTuple{6, Any}","page":"Home","title":"Jutul.solve_adjoint_sensitivities!","text":"solve_adjoint_sensitivities!(∇G, storage, states, state0, timesteps, G; forces = setup_forces(model))\n\nNon-allocating version of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.solve_adjoint_sensitivities-NTuple{4, Any}","page":"Home","title":"Jutul.solve_adjoint_sensitivities","text":"solve_adjoint_sensitivities(model, states, reports, G; extra_timing = false, state0 = setup_state(model), forces = setup_forces(model), raw_output = false, kwarg...)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nSolves the adjoint equations: For model equations F the gradient with respect to parameters p is     ∇ₚG = Σₙ (∂Fₙ / ∂p)ᵀ λₙ where n ∈ [1, N]. Given Lagrange multipliers λₙ from the adjoint equations     (∂Fₙ / ∂xₙ)ᵀ λₙ = - (∂J / ∂xₙ)ᵀ - (∂Fₙ₊₁ / ∂xₙ)ᵀ λₙ₊₁ where the last term is omitted for step n = N and G is the objective function.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.solve_numerical_sensitivities-NTuple{5, Any}","page":"Home","title":"Jutul.solve_numerical_sensitivities","text":"solve_numerical_sensitivities(model, states, reports, G, target;\n                                            forces = setup_forces(model),\n                                            state0 = setup_state(model),\n                                            parameters = setup_parameters(model),\n                                            epsilon = 1e-8)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nThis method uses numerical perturbation and is primarily intended for testing of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.solve_timestep!-NTuple{5, Any}","page":"Home","title":"Jutul.solve_timestep!","text":"solve_timestep!(sim, dT, forces, max_its, config; <keyword arguments>)\n\nInternal function for solving a single time-step with fixed driving forces.\n\nArguments\n\nsim: Simulator instance.\ndT: time-step to be solved\nforces: Driving forces for the time-step\nmax_its: Maximum number of steps/Newton iterations.\nconfig: Configuration for solver (typically output from simulator_config).\n\nNote: This function is exported for fine-grained simulation workflows. The general simulate interface is both easier to use and performs additional validation.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.spu_upwind-Union{Tuple{I}, Tuple{R}, Tuple{I, I, R, AbstractArray{R}}} where {R<:Real, I<:Integer}","page":"Home","title":"Jutul.spu_upwind","text":"Perform single-point upwinding based on signed potential.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.spu_upwind_mult-NTuple{4, Any}","page":"Home","title":"Jutul.spu_upwind_mult","text":"Perform single-point upwinding based on signed potential, then multiply the result with that potential\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.spu_upwind_mult_index-NTuple{4, Any}","page":"Home","title":"Jutul.spu_upwind_mult_index","text":"Perform single-point upwinding based on signed potential, then multiply the result with that potential\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.subvariable-Tuple{Any, Any}","page":"Home","title":"Jutul.subvariable","text":"subvariable(var, map)\n\nGet subvariable of Jutul variable\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.synchronize-Tuple{JutulContext}","page":"Home","title":"Jutul.synchronize","text":"Synchronize backend after allocations.\n\nSome backends may require notification that storage has been allocated.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.tpfv_geometry","page":"Home","title":"Jutul.tpfv_geometry","text":"tpfv_geometry(g)\n\nGenerate two-point finite-volume geometry for a given grid, if supported.\n\nSee also TwoPointFiniteVolumeGeometry.\n\n\n\n\n\n","category":"function"},{"location":"#Jutul.transfer-Tuple{Any, Any}","page":"Home","title":"Jutul.transfer","text":"Transfer v to the representation expected by a given context.\n\nFor the defalt context, the transfer function does nothing. For other context such as the CUDA version, it may convert integers and floats to other types (e.g. Float32) and Arrays to CuArrays.\n\nYou will likely have to implement some transfer operators for your own types if you want to simulate with a non-default context.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.two_point_potential_drop-NTuple{5, Real}","page":"Home","title":"Jutul.two_point_potential_drop","text":"Two-point potential drop with gravity (generic)\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.two_point_potential_drop_half_face-Tuple{Any, Any, AbstractVector, Any, Any}","page":"Home","title":"Jutul.two_point_potential_drop_half_face","text":"Two-point potential drop (with derivatives only respect to \"c_self\")\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.update_before_step!-NTuple{4, Any}","page":"Home","title":"Jutul.update_before_step!","text":"\n\n\n\n","category":"method"},{"location":"#Jutul.update_equation!-Tuple{Any, JutulEquation, Any, Any, Any}","page":"Home","title":"Jutul.update_equation!","text":"Update equation based on currently stored properties\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.update_equations!","page":"Home","title":"Jutul.update_equations!","text":"update_equations!(storage, model, dt = nothing)\n\nUpdate the governing equations using the current set of primary variables, parameters and secondary variables. Does not fill linearized system.\n\n\n\n\n\n","category":"function"},{"location":"#Jutul.update_equations_and_apply_forces!-NTuple{4, Any}","page":"Home","title":"Jutul.update_equations_and_apply_forces!","text":"update_equations_and_apply_forces!(storage, model, dt, forces; time = NaN)\n\nUpdate the model equations and apply boundary conditions and forces. Does not fill linearized system.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.update_linearized_system!-Tuple{Any, JutulModel}","page":"Home","title":"Jutul.update_linearized_system!","text":"update_linearized_system!(storage, model::JutulModel; <keyword arguments>)\n\nUpdate the linearized system with the current set of equations.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.update_linearized_system_equation!-Tuple{Any, Any, Any, JutulEquation, CompactAutoDiffCache}","page":"Home","title":"Jutul.update_linearized_system_equation!","text":"Update a linearized system based on the values and derivatives in the equation.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.update_secondary_variable!-NTuple{5, Any}","page":"Home","title":"Jutul.update_secondary_variable!","text":"Update a secondary variable. Normally autogenerated with @jutul_secondary\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.update_state_dependents!-Tuple{Any, JutulModel, Any, Any}","page":"Home","title":"Jutul.update_state_dependents!","text":"update_state_dependents!(storage, model, dt, forces; time = NaN, update_secondary = true)\n\nPerform updates of everything that depends on the state: A full linearization for the current primary variables.\n\nThis includes properties, governing equations and the linearized system itself.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.update_values!-Tuple{AbstractArray, AbstractArray}","page":"Home","title":"Jutul.update_values!","text":"update_values!(x, dx)\n\nReplace values of x in-place by y, leaving x with the avlues of y and the partials of x.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.value-Tuple{AbstractDict}","page":"Home","title":"Jutul.value","text":"value(d::Dict)\n\nCall value on all elements of some Dict.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.value-Tuple{Any}","page":"Home","title":"Jutul.value","text":"Take value of AD.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.values_per_entity-Tuple{Any, JutulVariables}","page":"Home","title":"Jutul.values_per_entity","text":"Number of values held by a primary variable. Normally this is equal to the number of degrees of freedom, but some special primary variables are most conveniently defined by having N values and N-1 independent variables.\n\n\n\n\n\n","category":"method"},{"location":"#Jutul.@jutul_secondary-Tuple{Any}","page":"Home","title":"Jutul.@jutul_secondary","text":"Designate the function as updating a secondary variable.\n\nThe function is then declared, in addition to helpers that allows checking what the dependencies are and unpacking the dependencies from state.\n\nIf we define the following function annotated with the macro: @jutulsecondary function updateas_secondary!(target, var::MyVarType, model, a, b, c)     @. target = a + b / c end\n\nThe macro also defines:  function get_dependencies(var::MyVarType, model)    return [:a, :b, :c] end\n\nfunction updatesecondaryvariable!(arraytarget, var::MyVarType, model, state)     updateassecondary!(arraytarget, var, model, state.a, state.b, state.c) end\n\nNote that the names input arguments beyond the parameter dict matter, as these will be fetched from state.\n\n\n\n\n\n","category":"macro"}]
}
