var documenterSearchIndex = {"docs":
[{"location":"usage/#High-level-docstrings","page":"Usage","title":"High-level docstrings","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"This section lists the main interfaces for interacting with codes that use Jutul as their foundation.","category":"page"},{"location":"usage/#Setting-up-models","page":"Usage","title":"Setting up models","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"SimulationModel\nMultiModel","category":"page"},{"location":"usage/#Jutul.SimulationModel","page":"Usage","title":"Jutul.SimulationModel","text":"SimulationModel(domain, system; <kwarg>)\n\nInstantiate a model for a given system discretized on the domain.\n\n\n\n\n\nSimulationModel(g::JutulMesh, system; discretization = nothing, kwarg...)\n\nType that defines a simulation model - everything needed to solve the discrete equations.\n\nThe minimal setup requires a JutulMesh that defines topology together with a JutulSystem that imposes physical laws.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.MultiModel","page":"Usage","title":"Jutul.MultiModel","text":"MultiModel(models)\n\nA model variant that is made up of many named submodels, each a fully realized SimulationModel.\n\nmodels should be a NamedTuple or Dict{Symbol, JutulModel}.\n\n\n\n\n\n","category":"type"},{"location":"usage/","page":"Usage","title":"Usage","text":"Model API Getters","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Jutul.get_secondary_variables\nJutul.get_primary_variables\nJutul.get_parameters\nJutul.get_variables","category":"page"},{"location":"usage/#Jutul.get_secondary_variables","page":"Usage","title":"Jutul.get_secondary_variables","text":"get_secondary_variables(model::SimulationModel)\n\nGet the secondary variable definitions (as OrderedDict) for a given model.\n\nSecondary variables are variables that can be computed from the primary variables together with the parameters.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.get_primary_variables","page":"Usage","title":"Jutul.get_primary_variables","text":"get_primary_variables(model::SimulationModel)\n\nGet the primary variable definitions (as OrderedDict) for a given model.\n\nPrimary variables are sometimes referred to as solution variables or primary unknowns. The set of primary variables completely determines the state of the system together with the parameters.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.get_parameters","page":"Usage","title":"Jutul.get_parameters","text":"get_parameters(model::SimulationModel)\n\nGet the parameter definitions (as OrderedDict) for a given model.\n\nParameters are defined as static values in a forward simulation that combine with the primary variables to compute secondary variables and model equations.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.get_variables","page":"Usage","title":"Jutul.get_variables","text":"get_variables(model::SimulationModel)\n\nGet all variable definitions (as OrderedDict) for a given model.\n\nThis is the union of get_secondary_variables and get_primary_variables.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"Setters","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Jutul.set_secondary_variables!\nJutul.set_primary_variables!\nJutul.set_parameters!","category":"page"},{"location":"usage/#Jutul.set_secondary_variables!","page":"Usage","title":"Jutul.set_secondary_variables!","text":"set_secondary_variables!(model, varname = vardef)\nset_secondary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a secondary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.set_primary_variables!","page":"Usage","title":"Jutul.set_primary_variables!","text":"set_primary_variables!(model, varname = vardef)\nset_primary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a primary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.set_parameters!","page":"Usage","title":"Jutul.set_parameters!","text":"set_parameters!(model, parname = pardef)\n\nSet a parameter with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"Various","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Jutul.number_of_degrees_of_freedom\nJutul.number_of_values","category":"page"},{"location":"usage/#Jutul.number_of_degrees_of_freedom","page":"Usage","title":"Jutul.number_of_degrees_of_freedom","text":"Total number of degrees of freedom for a model, over all primary variables and all entities.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.number_of_values","page":"Usage","title":"Jutul.number_of_values","text":"Total number of values for a model, for a given type of variables over all entities\n\n\n\n\n\n","category":"function"},{"location":"usage/#Systems-and-domains","page":"Usage","title":"Systems and domains","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"JutulSystem\nJutulContext\nJutulDomain\nDiscretizedDomain\nJutul.JutulDiscretization","category":"page"},{"location":"usage/#Jutul.JutulSystem","page":"Usage","title":"Jutul.JutulSystem","text":"Abstract type for the physical system to be solved.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JutulContext","page":"Usage","title":"Jutul.JutulContext","text":"Abstract type for the context Jutul should execute in (matrix formats, memory allocation, etc.)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JutulDomain","page":"Usage","title":"Jutul.JutulDomain","text":"Abstract type for domains where equations can be defined\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.DiscretizedDomain","page":"Usage","title":"Jutul.DiscretizedDomain","text":"DiscretizedDomain(domain, disc = nothing)\n\nA type for a discretized domain of some other domain or mesh. May contain one or more discretizations as-needed to write equations.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JutulDiscretization","page":"Usage","title":"Jutul.JutulDiscretization","text":"Abstract type for a Jutul discretization\n\n\n\n\n\n","category":"type"},{"location":"usage/#Grids/meshes-and-geometry","page":"Usage","title":"Grids/meshes and geometry","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"JutulMesh\nJutul.CartesianMesh\nTwoPointFiniteVolumeGeometry\nJutul.tpfv_geometry\nJutul.number_of_cells","category":"page"},{"location":"usage/#Jutul.JutulMesh","page":"Usage","title":"Jutul.JutulMesh","text":"A mesh is a type of domain that has been discretized. Abstract subtype.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.CartesianMesh","page":"Usage","title":"Jutul.CartesianMesh","text":"CartesianMesh(dims, [Δ, [origin]])\n\nCreate a Cartesian mesh with dimensions specified by the Tuple dims.\n\nArguments\n\ndims::Tuple: Number of grid cells in each direction. For example, (nx, ny) will give a 2D grids with nx cells in the x-direction.\nΔ::Tuple=ones(length(dims)): Equal length to dims. First option: A Tuple of scalars where each entry is the length of each cell in that direction. For\n\nexample, specifying (Δx, Δy) for a uniform grid with each grid cell having area ofΔx*Δy. Second option: ATuple` of vectors where each entry contains the cell sizes in the direction.\n\norigin=zeros(length(dims)): The origin of the first corner in the grid.\n\nExamples\n\nGenerate a uniform 3D mesh that discretizes a domain of 2 by 3 by 5 units with 3 by 5 by 2 cells:\n\njulia> CartesianMesh((3, 5, 2), (2.0, 3.0, 5.0))\nCartesianMesh (3D) with 3x5x2=30 cells\n\nGenerate a non-uniform 2D mesh:\n\njulia> CartesianMesh((2, 3), ([1.0, 2.0], [0.1, 3.0, 2.5]))\nCartesianMesh (3D) with 3x5x2=30 cells\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.TwoPointFiniteVolumeGeometry","page":"Usage","title":"Jutul.TwoPointFiniteVolumeGeometry","text":"TwoPointFiniteVolumeGeometry(neighbors, areas, volumes, normals, cell_centers, face_centers)\n\nStore two-point geometry information for a given list of neighbors specified as a 2 by n matrix where n is the number of faces such that face i connectes cells N[1, i] and N[2, i].\n\nThe two-point finite-volume geometry contains the minimal set of geometry information required to compute standard finite-volume discretizations.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.tpfv_geometry","page":"Usage","title":"Jutul.tpfv_geometry","text":"tpfv_geometry(g)\n\nGenerate two-point finite-volume geometry for a given grid, if supported.\n\nSee also TwoPointFiniteVolumeGeometry.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.number_of_cells","page":"Usage","title":"Jutul.number_of_cells","text":"number_of_cells(g)::Integer\n\nGet the number of cells in a mesh.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Set-up-of-system","page":"Usage","title":"Set up of system","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"setup_state\nsetup_parameters\nsetup_state_and_parameters\nsetup_forces","category":"page"},{"location":"usage/#Jutul.setup_state","page":"Usage","title":"Jutul.setup_state","text":"setup_state(model::JutulModel, name1 = value1, name2 = value2)\n\nSet up a state for a given model with values for the primary variables defined in the model. Normally all primary variables must be initialized in this way.\n\nArguments\n\nname=value: The name of the primary variable together with the value(s) used to initialize the primary variable.\n\nA scalar (or short vector of the right size for VectorVariables) will be repeated over the entire domain, while a vector (or matrix for VectorVariables) with length (number of columns for VectorVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\nNote: You likely want to overload [setup_state!]@ref for a custom model instead of setup_state\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_parameters","page":"Usage","title":"Jutul.setup_parameters","text":"setup_parameters(model::JutulModel; name = value)\n\nSet up a parameter storage for a given model with values for the parameter defined in the model.\n\nArguments\n\nname=value: The name of the parameter together with the value(s) of the parameter.\n\nA scalar (or short vector of the right size for VectorVariables) will be repeated over the entire domain, while a vector (or matrix for VectorVariables) with length (number of columns for VectorVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_state_and_parameters","page":"Usage","title":"Jutul.setup_state_and_parameters","text":"state, prm = setup_state_and_parameters(model, init)\n\nSimultaneously set up state and parameters from a single init file (typically a Dict containing values that might either be initial values or parameters)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_forces","page":"Usage","title":"Jutul.setup_forces","text":"setup_forces(model::JutulModel; force_name = force_value)\n\nSet up forces for a given model. Keyword arguments varies depending on what the model supports.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulator-interfaces","page":"Usage","title":"Simulator interfaces","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Used to run simulations once a model has been set up.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"simulate\nsimulate!\nJutul.solve_timestep!","category":"page"},{"location":"usage/#Jutul.simulate","page":"Usage","title":"Jutul.simulate","text":"simulate(state0, model, timesteps, parameters = setup_parameters(model))\nsimulate(state0, model, timesteps, info_level = 3)\nsimulate(state0, model, timesteps; <keyword arguments>)\n\nSimulate a set of timesteps with model for the given initial state0 and optionally specific parameters. Additional keyword arguments are passed onto simulator_config and simulate!. This interface is primarily for convenience, as all storage for the simulator is allocated upon use and discared upon return. If you want to perform multiple simulations with the same model it is advised to instead instantiate Simulator  and combine it with simulate!.\n\nArguments\n\nstate0::Dict: initial state, typically created using setup_state for the model in use.\nmodel::JutulModel: model that describes the discretized system to solve, for example SimulationModel or MultiModel.\ntimesteps::AbstractVector: Vector of desired report steps. The simulator will perform time integration until sum(timesteps)  is reached, providing outputs at the end of each report step.\nparameters=setup_parameters(model): Optional overrides the default parameters for the model.\nforces=nothing: Either nothing (for no forces), a single set of forces from setup_forces(model) or a Vector of such forces with equal length to timesteps.\nrestart=nothing: If an integer is provided, the simulation will attempt to restart from that step. Requires that output_path is provided here or in the config.\nconfig=simulator_config(model): Configuration Dict that holds many fine grained settings for output, linear solver, time-steps, outputs etc.\n\nAdditional arguments are passed onto simulator_config.\n\nSee also simulate!, Simulator, SimulationModel, simulator_config.\n\n\n\n\n\nsimulate(state0, sim::JutulSimulator, timesteps::AbstractVector; parameters = nothing, kwarg...)\n\nSimulate a set of timesteps with simulator for the given initial state0 and optionally specific parameters.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.simulate!","page":"Usage","title":"Jutul.simulate!","text":"simulate!(sim::JutulSimulator, timesteps::AbstractVector; forces = nothing,\n                                                               config = nothing,\n                                                               initialize = true,\n                                                               restart = nothing,\n                                                               state0 = nothing,\n                                                               parameters = nothing,\n                                                               kwarg...)\n\nNon-allocating (or perhaps less allocating) version of simulate!.\n\nArguments\n\ninitialize=true: Perform internal updates as if this is the first time \n\nSee also simulate for additional supported input arguments.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.solve_timestep!","page":"Usage","title":"Jutul.solve_timestep!","text":"solve_timestep!(sim, dT, forces, max_its, config; <keyword arguments>)\n\nInternal function for solving a single time-step with fixed driving forces.\n\nArguments\n\nsim: Simulator instance.\ndT: time-step to be solved\nforces: Driving forces for the time-step\nmax_its: Maximum number of steps/Newton iterations.\nconfig: Configuration for solver (typically output from simulator_config).\n\nNote: This function is exported for fine-grained simulation workflows. The general simulate interface is both easier to use and performs additional validation.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"Configure a simulator:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Simulator\nsimulator_config\nJutulConfig\nadd_option!","category":"page"},{"location":"usage/#Jutul.Simulator","page":"Usage","title":"Jutul.Simulator","text":"Simulator(model; <kwarg>)\n\nSet up a simulator object for a model that can be used by simulate!. To avoid manually instantiating the simulator, the non-mutating simulate interface can be used instead.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.simulator_config","page":"Usage","title":"Jutul.simulator_config","text":"simulator_config(sim; info_level = 3, linear_solver = GenericKrylov())\n\nSet up a simulator configuration object that can be passed onto simulate!.\n\nThere are many options available to configure a given simulator. The best way to get an overview of these possible configuration options is to instatiate the config without any arguments and inspecting the resulting table by calling simulator_config(sim) in the REPL.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.JutulConfig","page":"Usage","title":"Jutul.JutulConfig","text":"JutulConfig(name = nothing)\n\nA configuration object that acts like a Dict{Symbol,Any} but contains additional data to limit the valid keys and values to those added by add_option!\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.add_option!","page":"Usage","title":"Jutul.add_option!","text":"add_option!(opts::JutulConfig, :my_cool_option, 3, \"My option has this brief description\")\n\nAdd an option to existing JutulConfig structure. Additional currently undocumented keyword arguments can be used to restrict valid types and values.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sensitivities,-adjoints-and-optimization","page":"Usage","title":"Sensitivities, adjoints and optimization","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"solve_adjoint_sensitivities\nsolve_adjoint_sensitivities!\nJutul.solve_numerical_sensitivities\nsetup_parameter_optimization","category":"page"},{"location":"usage/#Jutul.solve_adjoint_sensitivities","page":"Usage","title":"Jutul.solve_adjoint_sensitivities","text":"solve_adjoint_sensitivities(model, states, reports, G; extra_timing = false, state0 = setup_state(model), forces = setup_forces(model), raw_output = false, kwarg...)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nSolves the adjoint equations: For model equations F the gradient with respect to parameters p is     ∇ₚG = Σₙ (∂Fₙ / ∂p)ᵀ λₙ where n ∈ [1, N]. Given Lagrange multipliers λₙ from the adjoint equations     (∂Fₙ / ∂xₙ)ᵀ λₙ = - (∂J / ∂xₙ)ᵀ - (∂Fₙ₊₁ / ∂xₙ)ᵀ λₙ₊₁ where the last term is omitted for step n = N and G is the objective function.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.solve_adjoint_sensitivities!","page":"Usage","title":"Jutul.solve_adjoint_sensitivities!","text":"solve_adjoint_sensitivities!(∇G, storage, states, state0, timesteps, G; forces = setup_forces(model))\n\nNon-allocating version of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.solve_numerical_sensitivities","page":"Usage","title":"Jutul.solve_numerical_sensitivities","text":"solve_numerical_sensitivities(model, states, reports, G, target;\n                                            forces = setup_forces(model),\n                                            state0 = setup_state(model),\n                                            parameters = setup_parameters(model),\n                                            epsilon = 1e-8)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nThis method uses numerical perturbation and is primarily intended for testing of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_parameter_optimization","page":"Usage","title":"Jutul.setup_parameter_optimization","text":"setup_parameter_optimization(model, state0, param, dt, forces, G, opt_cfg = optimization_config(model, param);\n                                                        grad_type = :adjoint,\n                                                        config = nothing,\n                                                        print = 1,\n                                                        copy_case = true,\n                                                        param_obj = false,\n                                                        kwarg...)\n\nSet up function handles for optimizing the case defined by the inputs to simulate together with a per-timestep objective function G.\n\nGenerally calling either of the functions will mutate the data Dict. The options are: Fo(x) -> evaluate objective dFo(dFdx, x) -> evaluate gradient of objective, mutating dFdx (may trigger evaluation of Fo) Fand_dF(F, dFdx, x) -> evaluate F and/or dF. Value of nothing will mean that the corresponding entry is skipped.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Linear-solvers","page":"Usage","title":"Linear solvers","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"GenericKrylov\nLUSolver","category":"page"},{"location":"usage/#Jutul.GenericKrylov","page":"Usage","title":"Jutul.GenericKrylov","text":"GenericKrylov(solver = :gmres; preconditioner = nothing; <kwarg>)\n\nSolver that wraps Krylov.jl with support for preconditioning.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.LUSolver","page":"Usage","title":"Jutul.LUSolver","text":"LUSolver(; reuse_memory = true, check = true, max_size = 50000)\n\nDirect solver that calls lu directly. Direct solvers are highly accurate, but are costly in terms of memory usage and execution speed for larger systems.\n\n\n\n\n\n","category":"type"},{"location":"usage/","page":"Usage","title":"Usage","text":"Preconditioners","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"AMGPreconditioner\nILUZeroPreconditioner\nJacobiPreconditioner\nSPAI0Preconditioner\nLUPreconditioner\nGroupWisePreconditioner","category":"page"},{"location":"usage/#Jutul.AMGPreconditioner","page":"Usage","title":"Jutul.AMGPreconditioner","text":"AMG on CPU (Julia native)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.ILUZeroPreconditioner","page":"Usage","title":"Jutul.ILUZeroPreconditioner","text":"ILU(0) preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JacobiPreconditioner","page":"Usage","title":"Jutul.JacobiPreconditioner","text":"Damped Jacobi preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.SPAI0Preconditioner","page":"Usage","title":"Jutul.SPAI0Preconditioner","text":"Sparse Approximate Inverse preconditioner of lowest order – SPAI(0)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.LUPreconditioner","page":"Usage","title":"Jutul.LUPreconditioner","text":"Full LU factorization as preconditioner (intended for smaller subsystems)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.GroupWisePreconditioner","page":"Usage","title":"Jutul.GroupWisePreconditioner","text":"Multi-model preconditioners\n\n\n\n\n\n","category":"type"},{"location":"usage/#Execution-contexts","page":"Usage","title":"Execution contexts","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Jutul.DefaultContext\nJutul.ParallelCSRContext","category":"page"},{"location":"usage/#Jutul.DefaultContext","page":"Usage","title":"Jutul.DefaultContext","text":"Default context\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.ParallelCSRContext","page":"Usage","title":"Jutul.ParallelCSRContext","text":"A context that uses a CSR sparse matrix format together with threads. Experimental.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Jutul","category":"page"},{"location":"#Jutul-documentation","page":"Home","title":"Jutul documentation","text":"","category":"section"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Jutul is an experimental Julia framework for multiphysics processes based on implicit finite-volume methods with automatic differentiation. The main public demonstrator is JutulDarcy.jl - a fully differentiable porous media simulator with excellent performance.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"CurrentModule = Jutul","category":"page"},{"location":"internals/#Internal-docstrings","page":"Internals","title":"Internal docstrings","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"These functions are mostly relevant for implementing simulators in the Jutul framework.","category":"page"},{"location":"internals/#Entities-and-variables","page":"Internals","title":"Entities and variables","text":"","category":"section"},{"location":"internals/#Variables","page":"Internals","title":"Variables","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Variable types:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"JutulVariables\nScalarVariable\nVectorVariables","category":"page"},{"location":"internals/#Jutul.JutulVariables","page":"Internals","title":"Jutul.JutulVariables","text":"Abstract type for all variables in Jutul.\n\nA variable is associated with a JutulEntity through the associated_entity function. A variable is local to that entity, and cannot depend on other entities. Variables are used by models to define:\n\nprimary variables: Sometimes referred to as degrees of freedom, primary unknowns or solution variables\nparameters: Static quantities that impact the solution\nsecondary variables: Can be computed from a combination of other primary and secondary variables and parameters.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.ScalarVariable","page":"Internals","title":"Jutul.ScalarVariable","text":"Abstract type for scalar variables (one entry per entity, e.g. pressure or temperature in each cell of a model)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.VectorVariables","page":"Internals","title":"Jutul.VectorVariables","text":"Abstract type for vector variables (more than one entry per entity, for example saturations or displacements)\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Internals","title":"Internals","text":"Variables API:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"degrees_of_freedom_per_entity\nvalues_per_entity\nmaximum_value\nminimum_value\nvariable_scale\nabsolute_increment_limit\nrelative_increment_limit\nassociated_entity","category":"page"},{"location":"internals/#Jutul.degrees_of_freedom_per_entity","page":"Internals","title":"Jutul.degrees_of_freedom_per_entity","text":"Number of independent primary variables / degrees of freedom per computational entity.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.values_per_entity","page":"Internals","title":"Jutul.values_per_entity","text":"Number of values held by a primary variable. Normally this is equal to the number of degrees of freedom, but some special primary variables are most conveniently defined by having N values and N-1 independent variables.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.maximum_value","page":"Internals","title":"Jutul.maximum_value","text":"Upper (inclusive) limit for variable.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.minimum_value","page":"Internals","title":"Jutul.minimum_value","text":"Lower (inclusive) limit for variable.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.variable_scale","page":"Internals","title":"Jutul.variable_scale","text":"Define a \"typical\" numerical value for a variable to scale the linear system entries.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.absolute_increment_limit","page":"Internals","title":"Jutul.absolute_increment_limit","text":"Absolute allowable change for variable during a nonlinear update.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.relative_increment_limit","page":"Internals","title":"Jutul.relative_increment_limit","text":"Relative allowable change for variable during a nonlinear update. A variable with value |x| and relative limit 0.2 cannot change more than |x|*0.2.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.associated_entity","page":"Internals","title":"Jutul.associated_entity","text":"Return the domain entity the equation is associated with\n\n\n\n\n\nThe entity a variable is associated with, and can hold partial derivatives with respect to.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"Updating variables","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"@jutul_secondary\nJutul.get_dependencies","category":"page"},{"location":"internals/#Jutul.@jutul_secondary","page":"Internals","title":"Jutul.@jutul_secondary","text":"Designate the function as updating a secondary variable.\n\nA generic evaluator is then defined, together with a function for getting the dependencies of that function upon the state. This is most easily documented with an example. If we define the following function annotated with the macro when updating the array containing the values of MyVarType realized for some model:\n\n@jutul_secondary function some_fn!(target, var::MyVarType, model, a, b, c, ix)\n    for i in ix\n        target[i] = a[i] + b[i] / c[i]\n    end\nend\n\nThe purpose of the macro is to translate this into two functions. The first defines for the dependencies of the function with respect to the fields of the state (primary variables, secondary variables and parameters):\n\nfunction get_dependencies(var::MyVarType, model)\n   return (:a, :b, :c)\nend\n\nThe second function defines a generic version that takes in state, and automatically expands the set of dependencies into getfield calls.\n\nfunction update_secondary_variable!(array_target, var::MyVarType, model, state, ix)\n    some_fn!(array_target, var, model, state.a, state.b, state.c, ix)\nend\n\nNote that the input names of arguments 4 to end-1 matter, as these will be fetched from state, exactly as written.\n\n\n\n\n\n","category":"macro"},{"location":"internals/#Jutul.get_dependencies","page":"Internals","title":"Jutul.get_dependencies","text":"Get dependencies of variable when viewed as a secondary variable. Normally autogenerated with @jutul_secondary\n\n\n\n\n\n","category":"function"},{"location":"internals/#Entities","page":"Internals","title":"Entities","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JutulEntity\nCells\nFaces\nNodes","category":"page"},{"location":"internals/#Jutul.JutulEntity","page":"Internals","title":"Jutul.JutulEntity","text":"Super-type for all entities where JutulVariables can be defined.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.Cells","page":"Internals","title":"Jutul.Cells","text":"Entity for Cells (closed volumes with averaged properties for a finite-volume solver)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.Faces","page":"Internals","title":"Jutul.Faces","text":"Entity for Faces (intersection between pairs of Cells)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.Nodes","page":"Internals","title":"Jutul.Nodes","text":"Entity for Nodes (intersection between multiple Faces)\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Internals","title":"Internals","text":"Entities API","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"number_of_partials_per_entity\nnumber_of_entities","category":"page"},{"location":"internals/#Jutul.number_of_partials_per_entity","page":"Internals","title":"Jutul.number_of_partials_per_entity","text":"number_of_partials_per_entity(model::SimulationModel, entity::JutulEntity)\n\nGet the number of local partial derivatives per entity in a model for a given JutulEntity. This is the sum of degrees_of_freedom_per_entity for all primary variables defined on entity.\n\n\n\n\n\nGet the number of partials\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.number_of_entities","page":"Internals","title":"Jutul.number_of_entities","text":"Get the number of entities (e.g. the number of cells) that the equation is defined on.\n\n\n\n\n\nGet number of entities a cache is defined on.\n\n\n\n\n\nNumber of entities for vector stored in state (just the number of elements)\n\n\n\n\n\nNumber of entities for matrix stored in state (convention is number of columns)\n\n\n\n\n\nNumber of entities (e.g. Cells, Faces) a variable is defined on. By default, each primary variable exists on all cells of a discretized domain\n\n\n\n\n\n","category":"function"},{"location":"internals/#Equations","page":"Internals","title":"Equations","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JutulEquation","category":"page"},{"location":"internals/#Jutul.JutulEquation","page":"Internals","title":"Jutul.JutulEquation","text":"Abstract type for all residual equations\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Internals","title":"Internals","text":"Equations API","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Jutul.number_of_equations\nJutul.number_of_equations_per_entity","category":"page"},{"location":"internals/#Jutul.number_of_equations","page":"Internals","title":"Jutul.number_of_equations","text":"Get the total number of equations on the domain of model.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.number_of_equations_per_entity","page":"Internals","title":"Jutul.number_of_equations_per_entity","text":"Get the number of equations per entity. For example, mass balance of two components will have two equations per grid cell (= entity)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Automatic-differentiation","page":"Internals","title":"Automatic differentiation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Jutul.value\nJutul.as_value\nJutul.local_ad\nJutul.JutulAutoDiffCache\nJutul.CompactAutoDiffCache\nJutul.allocate_array_ad\nJutul.get_ad_entity_scalar\nJutul.get_entries","category":"page"},{"location":"internals/#Jutul.value","page":"Internals","title":"Jutul.value","text":"Take value of AD.\n\n\n\n\n\nvalue(d::Dict)\n\nCall value on all elements of some Dict.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.as_value","page":"Internals","title":"Jutul.as_value","text":"Create a mapped array that produces only the values when indexed.\n\nOnly useful for AD arrays, otherwise it does nothing.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.local_ad","page":"Internals","title":"Jutul.local_ad","text":"local_ad(state::T, index::I, ad_tag::∂T) where {T, I<:Integer, ∂T}\n\nCreate localad for state for index I of AD tag of type adtag\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.JutulAutoDiffCache","page":"Internals","title":"Jutul.JutulAutoDiffCache","text":"An AutoDiffCache is a type that holds both a set of AD values and a map into some global Jacobian.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.CompactAutoDiffCache","page":"Internals","title":"Jutul.CompactAutoDiffCache","text":"Cache that holds an AD vector/matrix together with their positions.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.allocate_array_ad","page":"Internals","title":"Jutul.allocate_array_ad","text":"allocate_array_ad(n[, m]; <keyword arguments>)\n\nAllocate vector or matrix as AD with optionally provided context and a specified non-zero on the diagonal.\n\nArguments\n\nn::Integer: number of entries in vector, or number of rows if m is given.\nm::Integer: number of rows (optional)\n\nKeyword arguments\n\nnpartials = 1: Number of partials derivatives to allocate for each element\ndiag_pos = nothing: Indices of where to put entities on the diagonal (if any)\n\nOther keyword arguments are passed onto get_ad_entity_scalar.\n\nExamples:\n\nAllocate a vector with a single partial:\n\njulia> allocate_array_ad(2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 1}}:\n Dual{nothing}(0.0,0.0)\n Dual{nothing}(0.0,0.0)\n\nAllocate a vector with two partials, and set the first to one:\n\njulia> allocate_array_ad(2, diag_pos = 1, npartials = 2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,1.0,0.0)\n\nSet up a matrix with two partials, where the first column has partials [1, 0] and the second [0, 1]:\n\njulia> allocate_array_ad(2, 2, diag_pos = [1, 2], npartials = 2)\n2×2 Matrix{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)  Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,0.0,1.0)  Dual{nothing}(0.0,0.0,1.0)\n\n\n\n\n\nallocate_array_ad(v::AbstractVector, ...)\n\nConvert vector to AD vector.\n\n\n\n\n\nallocate_array_ad(v::AbstractMatrix, ...)\n\nConvert matrix to AD matrix.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.get_ad_entity_scalar","page":"Internals","title":"Jutul.get_ad_entity_scalar","text":"get_ad_entity_scalar(v::Real, npartials, diag_pos = nothing; <keyword_arguments>)\n\nGet scalar with partial derivatives as AD instance.\n\nArguments\n\nv::Real: Value of AD variable.\nnpartials: Number of partial derivatives each AD instance holds.\ndiag_pos = nothing: Position(s) of where to set 1 as the partial derivative instead of zero.\n\nKeyword arguments\n\ntag = nothing: Tag for AD instance. Two AD values of the different tag cannot interoperate to avoid perturbation confusion (see ForwardDiff documentation).\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.get_entries","page":"Internals","title":"Jutul.get_entries","text":"Get the entries of the main autodiff cache for an equation.\n\nNote: This only gets the .equation field's entries.\n\n\n\n\n\nGet entries of autodiff cache. Entries are AD vectors that hold values and derivatives.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Matrix","page":"Internals","title":"Matrix","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Jutul.JutulMatrixLayout\nJutul.EntityMajorLayout\nJutul.EquationMajorLayout\nJutul.BlockMajorLayout","category":"page"},{"location":"internals/#Jutul.JutulMatrixLayout","page":"Internals","title":"Jutul.JutulMatrixLayout","text":"Abstract type for matrix layouts. A layout determines how primary variables and equations are ordered in a sparse matrix representation. Note that this is different from the matrix format itself as it concerns the ordering itself: For example, if all equations for a single cell come in sequence, or if a single equation is given for all entities before the next equation is written.\n\nDifferent layouts does not change the solution of the system, but different linear solvers support different layouts.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.EntityMajorLayout","page":"Internals","title":"Jutul.EntityMajorLayout","text":"Equations are grouped by entity, listing all equations and derivatives for entity 1 before proceeding to entity 2 etc.\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E2/∂S)₁, (∂E1/∂p)₂, (∂E2/∂S)₂\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.EquationMajorLayout","page":"Internals","title":"Jutul.EquationMajorLayout","text":"Equations are stored sequentially in rows, derivatives of same type in columns:\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E1/∂p)₂, (∂E2/∂S)₁, (∂E2/∂S)₂\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.BlockMajorLayout","page":"Internals","title":"Jutul.BlockMajorLayout","text":"Same as EntityMajorLayout, but the system is a sparse matrix where each entry is a small dense matrix.\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give a diagonal of length 2: [(∂E1/∂p)₁ (∂E1/∂S)₁ ; (∂E2/∂p)₁ (∂E2/∂S)₁] [(∂E1/∂p)₂ (∂E1/∂S)₂ ; (∂E2/∂p)₂ (∂E2/∂S)₂]\n\n\n\n\n\n","category":"type"},{"location":"internals/#Various","page":"Internals","title":"Various","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"convergence_criterion\nJutul.partition\nJutul.load_balanced_endpoint","category":"page"},{"location":"internals/#Jutul.convergence_criterion","page":"Internals","title":"Jutul.convergence_criterion","text":"convergence_criterion(model, storage, eq, eq_s, r; dt = 1)\n\nGet the convergence criterion values for a given equation. Can be checked against the corresponding tolerances.\n\nArguments\n\nmodel: model that generated the current equation.\nstorage: global simulator storage.\neq::JutulEquation: equation implementation currently being checked\neq_s: storage for eq where values are contained.\nr: the local residual part corresponding to this model, as a matrix with column index equaling entity index\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.partition","page":"Internals","title":"Jutul.partition","text":"partition(N::AbstractMatrix, num_coarse, weights = ones(size(N, 2)); partitioner = MetisPartitioner(), groups = nothing, n = maximum(N))\n\nPartition based on neighborship (with optional groups kept contigious after partitioning)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.load_balanced_endpoint","page":"Internals","title":"Jutul.load_balanced_endpoint","text":"load_balanced_endpoint(block_index, nvals, nblocks)\n\nEndpoint for interval block_index that subdivides nvals into nblocks in a load balanced manner. This is done by adding one element to the first set of blocks whenever possible.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"<!– @autodocs  Modules = [Jutul] –>","category":"page"}]
}
