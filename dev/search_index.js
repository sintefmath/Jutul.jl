var documenterSearchIndex = {"docs":
[{"location":"optimization/#Sensitivities,-adjoints-and-optimization","page":"Sensitivities, adjoints and optimization","title":"Sensitivities, adjoints and optimization","text":"Jutul.jl is build from the ground up to support gradient-based optimization problems. This includes both data assimilation/parameter calibration and control problems.\n\nAn example application from JutulDarcy.jl demonstrates many of these functions: A fully differentiable geothermal doublet: History matching and control optimization","category":"section"},{"location":"optimization/#Objective-functions","page":"Sensitivities, adjoints and optimization","title":"Objective functions","text":"There are two main types of objective functions supported in Jutul: Those that evaluated globally over all time-steps, and those who are evaluated locally (typically as a sum over all time-steps).\n\nFor either type of objective, you must implement the correct interface. This can either be done by passing a function directly, with Jutul guessing from the number of arguments what kind of objective it is, or by explicitly making a subtype that is a Julia callable struct.\n\nThese functions take in the step_info Dict, which is worth having a look at if you plan on writing objective functions:","category":"section"},{"location":"optimization/#Global-objectives","page":"Sensitivities, adjoints and optimization","title":"Global objectives","text":"These are objectives that are defined over the entire simulation time. This means that you define the objective function as a single function that takes in the solution for all time-steps together with forces, time-step information, initial state and input data used to set up the model (if any).","category":"section"},{"location":"optimization/#Local/sum-objectives","page":"Sensitivities, adjoints and optimization","title":"Local/sum objectives","text":"","category":"section"},{"location":"optimization/#Generic-optimization-interface","page":"Sensitivities, adjoints and optimization","title":"Generic optimization interface","text":"The generic optimization interface is very general, handling gradients with respect to any parameter used in a function that sets up a complete simulation case from a AbstractDict. This makes use of AbstractDifferentiation.jl and the default configuration assumes that your setup function can be differentiated with the ForwardDiff backend. In practice, this means that you must take care when initializing arrays and other types so that they can fit the AD type (e.g. avoid use of zeros without a type). In addition, there may be a large number of calls to the setup function, which can sometimes be slow. Alternatively, the numerical parameter optimization interface can be used, which only differentiates with respect to numerical parameters inside the model. A hybrid approach is also supported for the generic optimization interface by setting the deps and deps_ad arguments to optimize, which can be much faster, but assumes that the optimization variables only affect the numerical parameters/variables of the model (values stored in the Dicts from setup_parameters and setup_state0) and not any values that exist e.g. inside the model itself.","category":"section"},{"location":"optimization/#Defining-the-parameter-object","page":"Sensitivities, adjoints and optimization","title":"Defining the parameter object","text":"","category":"section"},{"location":"optimization/#Defining-constraints-and-free-parameters","page":"Sensitivities, adjoints and optimization","title":"Defining constraints and free parameters","text":"","category":"section"},{"location":"optimization/#Optimizing-and-computing-gradients","page":"Sensitivities, adjoints and optimization","title":"Optimizing and computing gradients","text":"","category":"section"},{"location":"optimization/#Numerical-parameter-optimization-interface","page":"Sensitivities, adjoints and optimization","title":"Numerical parameter optimization interface","text":"","category":"section"},{"location":"optimization/#Jutul.AbstractJutulObjective","page":"Sensitivities, adjoints and optimization","title":"Jutul.AbstractJutulObjective","text":"Abstract type for Jutul objectives.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Jutul.optimization_step_info","page":"Sensitivities, adjoints and optimization","title":"Jutul.optimization_step_info","text":"optimization_step_info(step::Int, time::Real, dt; kwarg...)\n\nOptimization step information is normally not set up manually, but the output from this function will be passed to objective functions as step_info. This function is a Dict with the following fields:\n\nFields\n\n:time - The time at the end of the step. To get time at the start of the step, use step_info[:time] - step_info[:dt]\n:dt - The time step size for this step.\n:step - The step number, starting at 1. Not that this is the report step, and multiple step_info entries could have the same step if substeps are used.\n:Nstep - The total number of steps in the simulation. \n:substep - The substep number, starting at 1. This is used to indicate that multiple steps are taken within a single step.\n:substep_global - The global substep number, starting at 1 and will not reset between global steps.\n:Nsubstep_global - The total number of substeps in the simulation.\n:total_time - The total time of the simulation (i.e. time at the final step and substep)\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.AbstractGlobalObjective","page":"Sensitivities, adjoints and optimization","title":"Jutul.AbstractGlobalObjective","text":"Abstract type for objective as a global objective function on the form:\n\nF(model, state0, states, step_infos, forces, input_data)\n\nNote that if substeps are enabled by setting output_substates=true in the simulator setup, the length of forces and states will be dynamic and of equal length to step_infos. If you want to recover the state at a specific step, you can reason about :step field of the corresponding entry in the step_infos array.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Jutul.WrappedGlobalObjective","page":"Sensitivities, adjoints and optimization","title":"Jutul.WrappedGlobalObjective","text":"WrappedGlobalObjective(objective)\n\nA global (in time) objective that wraps a function/callable. This type automatically wraps functions/callable structs that are passed to the optimization interface if they have the sum signature (five arguments).\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Jutul.AbstractSumObjective","page":"Sensitivities, adjoints and optimization","title":"Jutul.AbstractSumObjective","text":"Abstract type for objective as a sum of function values on the form:\n\nF(model, state, dt, step_info, forces)\n\nevaluated for each step. This means that the objective is a sum of all of these values. If you want to only depend on a single step, you can look up\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Jutul.WrappedSumObjective","page":"Sensitivities, adjoints and optimization","title":"Jutul.WrappedSumObjective","text":"WrappedSumObjective(objective)\n\nAn objective that is a sum of function values, evaluated for each step, defined by a function. This type automatically wraps functions/callable structs that are passed to the optimization interface if they have the sum signature (five arguments).\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Jutul.DictOptimization.DictParameters","page":"Sensitivities, adjoints and optimization","title":"Jutul.DictOptimization.DictParameters","text":"DictParameters(parameters)\nDictParameters(parameters::AbstractDict, setup_function = missing;\n        strict = true,\n        verbose = true,\n        active_type = Float64\n    )\n\nSet up a DictParameters object for optimization. Optionally, the setup function that takes an instance with the same keys as parameters together with a step_info dictionary can be provided. The setup function should return a JutulCase set up from the parameters in the Dict.\n\nOptional keyword arguments:\n\nstrict: If true, the optimization will throw an error if any of the parameters are not set with at least one of the upper or lower bounds.\nverbose: If true, the optimization will print information about the optimization process.\nactive_type: The type of the parameters that are considered active in the optimization. Defaults to Float64. This is used to determine which parameters are active and should be optimized. This means that all entries (and entries in nested dictionaries) of the parameters dictionary must be of this type or an array with this type as element type.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Jutul.DictOptimization.free_optimization_parameter!","page":"Sensitivities, adjoints and optimization","title":"Jutul.DictOptimization.free_optimization_parameter!","text":"free_optimization_parameter!(dopt, \"parameter_name\", rel_min = 0.01, rel_max = 100.0)\nfree_optimization_parameter!(dopt, [\"dict_name\", \"parameter_name\"], abs_min = -8.0, abs_max = 7.0)\n\nFree an existing parameter for optimization in the DictParameters object. This will allow the parameter to be optimized through a call to optimize.\n\nNesting structures\n\nIf your DictParameters has a nesting structure, you can use a vector of strings or symbols to specify the parameter name, e.g. [\"dict_name\", \"parameter_name\"] to access the parameter located at [\"dict_name\"][\"parameter_name\"].\n\nSetting limits\n\nThe limits can be set using the following keyword arguments:\n\nabs_min: Absolute minimum value for the parameter.  If not set, no absolute minimum will be applied.\nabs_max: Absolute maximum value for the parameter. If not set, no absolute maximum will be applied.\nrel_min: Relative minimum value for the parameter. If not set, no relative minimum will be applied.\nrel_max: Relative maximum value for the parameter. If not set, no relative maximum will be applied.\n\nFor either of these entries it is possible to pass either a scalar, or an array. If an array is passed, it must have the same size as the parameter being set.\n\nNote that if dopt.strict is set to true, at least one of the upper or lower bounds must be set for free parameters. If dopt.strict is set to false, the bounds are optional and the DictParameters object can be used to compute sensitivities, but the built-in optimization routine assumes that finite limits are set for all parameters.\n\nOther keyword arguments\n\ninitial: Initial value for the parameter. If not set, the current value in dopt.parameters will be used.\nscaler=missing: Optional scaler for the parameter. If not set, no scaling will be applied. Available scalers are:\n:log: Logarithmic scaling. This value uses shifts to avoid issues with zero values.\n:exp: Exponential scaling\n:linear: Linear scaling (scaling to bounds of values, guaranteeing values between between 0 and 1 for initial values.)\nlinear_limits: Linear scaling with limits (scaling to bounds of values, guaranteeing values between between 0 and 1 for all values within the limits.)\nreciprocal: Reciprocal scaling\nlog10: Base-10 logarithmic scaling\nlog: Base-e logarithmic scaling without shifts\nA custom scaler object implementing the DictOptimizationScaler interface.\nlumping=missing: Optional lumping array for the parameter. If not set, no lumping will be applied. The lumping array should have the same size as the parameter and contain positive integers. The lumping array defines groups of indices that should be lumped together, i.e. the same value will be used for all indices in the same group. The lumping array should contain all integers from 1 to the maximum value in the array, and all indices in the same group should have the same value in the initial parameter, otherwise an error will be thrown.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.DictOptimization.freeze_optimization_parameter!","page":"Sensitivities, adjoints and optimization","title":"Jutul.DictOptimization.freeze_optimization_parameter!","text":"freeze_optimization_parameter!(dopt, \"parameter_name\")\nfreeze_optimization_parameter!(dopt, [\"dict_name\", \"parameter_name\"])\nfreeze_optimization_parameter!(dopt::DictParameters, parameter_name, val = missing)\n\nFreeze an optimization parameter in the DictParameters object. This will remove the parameter from the optimization targets and set its value to val if provided. Any limits/lumping/scaling settings for this parameter will be removed.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.DictOptimization.set_optimization_parameter!","page":"Sensitivities, adjoints and optimization","title":"Jutul.DictOptimization.set_optimization_parameter!","text":"set_optimization_parameter!(dopt::DictParameters, parameter_name, value)\n\nSet a specific optimization parameter in the DictParameters object. This function will update the value of the parameter in the dopt.parameters dictionary.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.DictOptimization.add_optimization_multiplier!","page":"Sensitivities, adjoints and optimization","title":"Jutul.DictOptimization.add_optimization_multiplier!","text":"add_optimization_multiplier!(dprm::DictParameters, name_of_target; abs_min = 0.2, abs_max = 5.0)\nadd_optimization_multiplier!(dprm, target1, target2, target3; abs_min = 0.2, abs_max = 5.0, initial = 2.0)\n\nAdd an optimization multiplier that acts on one or more targets to the DictParameters object. The multiplier will be optimized during the optimization process. All parameters with the same multiplier must have the same dimensions.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.DictOptimization.optimize","page":"Sensitivities, adjoints and optimization","title":"Jutul.DictOptimization.optimize","text":"optimized_dict = optimize(dopt, objective)\noptimize(dopt::DictParameters, objective, setup_fn = dopt.setup_function;\n    grad_tol = 1e-6,\n    obj_change_tol = 1e-6,\n    max_it = 25,\n    opt_fun = missing,\n    maximize = false,\n    simulator = missing,\n    config = missing,\n    solution_history = false,\n    backend_arg = (\n        use_sparsity = false,\n        di_sparse = true,\n        single_step_sparsity = false,\n        do_prep = true,\n    ),\n    kwarg...\n)\n\nOptimize parameters defined in a DictParameters object using the provided objective function. At least one variable has to be declared to be free using free_optimization_parameter! prior to calling the optimizer.\n\nArguments\n\ndopt::DictParameters: Container with parameters to optimize\nobjective: The objective function to minimize (or maximize)\nsetup_fn: Function to set up the optimization problem. Defaults to dopt.setup_function\n\nKeyword Arguments\n\ngrad_tol: Gradient tolerance for stopping criterion\nobj_change_tol: Objective function change tolerance for stopping criterion\nmax_it: Maximum number of iterations\noptimizer: Symbol defining the optimization algorithm to use. Available options are :lbfgs (default), :lbfgsb_qp and :lbfgsb (requires LBFGSB.jl to be imported)\nopt_fun: Optional custom optimization function. If missing, L-BFGS will be used. Takes in a NamedTuple containing fields f, g, x0, min, max. Here, f(x) returns the objective function value at x, g(dFdx, x) fills dFdx with the gradient at x, x0 is the initial guess, and min and max are the lower and upper bounds, respectively. The functions u = F.scale(x) and x = F.descale(u) can be used to convert between scaled and unscaled variables. Nominally, the initial values are scaled to the unit cube and the solution must thus be unscaled before usage. Gradients and internal scaling/descaling is automatically handled.\nmaximize: Set to true to maximize the objective instead of minimizing\ngradient_scaling: If true, internally scales the objective gradient according to the initial 2-norm of the gradient. If a Float64 value is provided, that value is used as a global scaling factor for the gradient. The internal gradient and objective value is divided by the chosen scaling.\nsimulator: Optional simulator object used in forward simulations\nconfig: Optional configuration for the setup\nsolution_history: If true, stores all intermediate solutions\ndeps: One of :case, :parameters, :parameters_and_state0. Defines the dependencies for the adjoint computation. See notes for more details.\nbackend_arg: Options for the autodiff backend:\nuse_sparsity: Enable sparsity detection for the objective function\ndi_sparse: Use sparse differentiation\nsingle_step_sparsity: Enable single step sparsity detection (if sparsity does not change during timesteps). This means that the solver will assume that the sparsity pattern will be determined entirely by the first and last steps of the simulation. Alternatively, this can be set to :unique_forces to use the sparsity pattern determined by all unique force terms in the solve, :firstlast to only use the first and last time steps or :allsteps to use all time steps (the latter is equivalent to setting use_sparsity to true).\ndo_prep: Perform preparation step\noutput_path: If provided, the optimization results will be stored in the given path as a JLD2 file named final.jld2, with intermediate steps being stored as step_1.jld2, step_2.jld2, etc if solution_history is enabled.\n\nReturns\n\nThe optimized parameters as a dictionary.\n\nNotes\n\nThe function stores the optimization history and optimized parameters in the input dopt object.\nIf solution_history is true or :x, intermediate solutions are stored in dopt.history.solutions. If it is set to :full, the full states are also copied and stored for each iteration. This can use a lot of memory for large simulations.\nThe default optimization algorithm is L-BFGS with box constraints.\n\nType of dependencies in deps\n\nThe deps argument is used to set the type of dependency the case setup function has on the active optimization parameters. The default, :case, is fully general and allows dependencies on everything contained within the case instance. This can be slow, however, as the setup function must be called for every time-step. If you know that the model instance and forces are independent of the active parameters, you can use deps = :parameters_and_state0. If there is no dependence on state0, you can set deps = :parameters. This can substantially speed up the optimization process, but as there is no programmatic verification that this assumption is true, it should be used with care.\n\nThis interface is dependent on the model supporting use of vectorize_variables! and devectorize_variables! for state0/parameters, which should be the case for most Jutul models.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.DictOptimization.parameters_gradient","page":"Sensitivities, adjoints and optimization","title":"Jutul.DictOptimization.parameters_gradient","text":"parameters_gradient(dopt::DictParameters, objective, setup_fn = dopt.setup_function)\n\nCompute the gradient of the objective function with respect to the parameters defined in the DictParameters object. This function will return the gradient as a dictionary with the same structure as the input parameters, where each entry is a vector of gradients for each parameter. Only gradients with respect to free parameters will be computed.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.solve_adjoint_sensitivities","page":"Sensitivities, adjoints and optimization","title":"Jutul.solve_adjoint_sensitivities","text":"solve_adjoint_sensitivities(model, states, reports_or_timesteps, G; extra_timing = false, state0 = setup_state(model), forces = setup_forces(model), raw_output = false, kwarg...)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nThe objective function is at the moment assumed to be a sum over all states on the form: obj = Σₙ G(model, state, dt_n, n, forces_for_step_n)\n\nSolves the adjoint equations: For model equations F the gradient with respect to parameters p is     ∇ₚG = Σₙ (∂Fₙ / ∂p)ᵀ λₙ where n ∈ [1, N]. Given Lagrange multipliers λₙ from the adjoint equations     (∂Fₙ / ∂xₙ)ᵀ λₙ = - (∂J / ∂xₙ)ᵀ - (∂Fₙ₊₁ / ∂xₙ)ᵀ λₙ₊₁ where the last term is omitted for step n = N and G is the objective function.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.solve_adjoint_sensitivities!","page":"Sensitivities, adjoints and optimization","title":"Jutul.solve_adjoint_sensitivities!","text":"solve_adjoint_sensitivities!(∇G, storage, states, state0, timesteps, G; forces)\n\nNon-allocating version of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.solve_numerical_sensitivities","page":"Sensitivities, adjoints and optimization","title":"Jutul.solve_numerical_sensitivities","text":"solve_numerical_sensitivities(model, states, reports, G, target;\n                                            forces = setup_forces(model),\n                                            state0 = setup_state(model),\n                                            parameters = setup_parameters(model),\n                                            epsilon = 1e-8)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nThis method uses numerical perturbation and is primarily intended for testing of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Jutul.setup_parameter_optimization","page":"Sensitivities, adjoints and optimization","title":"Jutul.setup_parameter_optimization","text":"setup_parameter_optimization(model, state0, param, dt, forces, G, opt_cfg = optimization_config(model, param);\n    grad_type = :adjoint,\n    config = nothing,\n    print = 1,\n    copy_case = true,\n    param_obj = false,\n    kwarg...\n)\n\nSet up function handles for optimizing the case defined by the inputs to simulate together with a per-timestep objective function G. The objective function should fit the format described in AbstractGlobalObjective or AbstractSumObjective.\n\nGenerally calling either of the functions will mutate the data Dict. The options are:\n\nF_o(x): evaluate objective\ndF_o(dFdx, x): evaluate gradient of objective, mutating dFdx (may trigger evaluation of F_o)\nF_and_dF(F, dFdx, x): evaluate F and/or dF. If nothing is passed for an entry, the corresponding entry is skipped.\n\n\n\n\n\n","category":"function"},{"location":"usage/#High-level-docstrings","page":"Usage","title":"High-level docstrings","text":"This section lists the main interfaces for interacting with codes that use Jutul as their foundation.","category":"section"},{"location":"usage/#Setting-up-models","page":"Usage","title":"Setting up models","text":"","category":"section"},{"location":"usage/#Model-API","page":"Usage","title":"Model API","text":"","category":"section"},{"location":"usage/#Getters","page":"Usage","title":"Getters","text":"Setters\n\nVarious","category":"section"},{"location":"usage/#Systems-and-domains","page":"Usage","title":"Systems and domains","text":"","category":"section"},{"location":"usage/#Set-up-of-system","page":"Usage","title":"Set up of system","text":"","category":"section"},{"location":"usage/#Simulator-interfaces","page":"Usage","title":"Simulator interfaces","text":"Used to run simulations once a model has been set up.\n\nConfigure a simulator:","category":"section"},{"location":"usage/#Linear-solvers","page":"Usage","title":"Linear solvers","text":"","category":"section"},{"location":"usage/#Preconditioners","page":"Usage","title":"Preconditioners","text":"","category":"section"},{"location":"usage/#Execution-contexts","page":"Usage","title":"Execution contexts","text":"","category":"section"},{"location":"usage/#Jutul.SimulationModel","page":"Usage","title":"Jutul.SimulationModel","text":"SimulationModel(domain, system; <kwarg>)\n\nInstantiate a model for a given system discretized on the domain.\n\n\n\n\n\nSimulationModel(g::JutulMesh, system; discretization = nothing, kwarg...)\n\nType that defines a simulation model - everything needed to solve the discrete equations.\n\nThe minimal setup requires a JutulMesh that defines topology together with a JutulSystem that imposes physical laws.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.MultiModel","page":"Usage","title":"Jutul.MultiModel","text":"MultiModel(models)\nMultiModel(models, :SomeLabel)\n\nA model variant that is made up of many named submodels, each a fully realized SimulationModel.\n\nmodels should be a NamedTuple or Dict{Symbol, JutulModel}.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.get_secondary_variables","page":"Usage","title":"Jutul.get_secondary_variables","text":"get_secondary_variables(model::SimulationModel)\n\nGet the secondary variable definitions (as OrderedDict) for a given model.\n\nSecondary variables are variables that can be computed from the primary variables together with the parameters.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.get_primary_variables","page":"Usage","title":"Jutul.get_primary_variables","text":"get_primary_variables(model::SimulationModel)\n\nGet the primary variable definitions (as OrderedDict) for a given model.\n\nPrimary variables are sometimes referred to as solution variables or primary unknowns. The set of primary variables completely determines the state of the system together with the parameters.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.get_parameters","page":"Usage","title":"Jutul.get_parameters","text":"get_parameters(model::SimulationModel)\n\nGet the parameter definitions (as OrderedDict) for a given model.\n\nParameters are defined as static values in a forward simulation that combine with the primary variables to compute secondary variables and model equations.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.get_variables","page":"Usage","title":"Jutul.get_variables","text":"get_variables(model::SimulationModel)\n\nGet all variable definitions (as OrderedDict) for a given model.\n\nThis is the union of get_secondary_variables and get_primary_variables.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.set_secondary_variables!","page":"Usage","title":"Jutul.set_secondary_variables!","text":"set_secondary_variables!(model, varname = vardef)\nset_secondary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a secondary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.set_primary_variables!","page":"Usage","title":"Jutul.set_primary_variables!","text":"set_primary_variables!(model, varname = vardef)\nset_primary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a primary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.set_parameters!","page":"Usage","title":"Jutul.set_parameters!","text":"set_parameters!(model, parname = pardef)\n\nSet a parameter with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.number_of_degrees_of_freedom","page":"Usage","title":"Jutul.number_of_degrees_of_freedom","text":"Total number of degrees of freedom for a model, over all primary variables and all entities.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.number_of_values","page":"Usage","title":"Jutul.number_of_values","text":"Total number of values for a model, for a given type of variables over all entities\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.JutulSystem","page":"Usage","title":"Jutul.JutulSystem","text":"Abstract type for the physical system to be solved.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JutulContext","page":"Usage","title":"Jutul.JutulContext","text":"Abstract type for the context Jutul should execute in (matrix formats, memory allocation, etc.)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JutulDomain","page":"Usage","title":"Jutul.JutulDomain","text":"Abstract type for domains where equations can be defined\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.DataDomain","page":"Usage","title":"Jutul.DataDomain","text":"DataDomain(domain::JutulDomain; property1 = p1, property2 = p2, ...)\n\nA wrapper around a domain that allows for storing of entity-associated data.\n\nExample:\n\n# Grid with 6 cells and 7 interior faces\ng = CartesianMesh((2, 3))\nd = DataDomain(g)\nd[:cell_vec] = rand(6) #ok, same as:\nd[:cell_vec, Cells()] = rand(6) #ok\nd[:cell_vec, Faces()] = rand(6) #not ok!\nd[:face_vec, Faces()] = rand(7) #ok!\n# Can also add general arrays if last dimension == entity dimension\nd[:cell_vec, Cells()] = rand(10, 3, 6) #ok\n# Can add general data too, but needs to be specified\nd[:not_on_face_or_cell, nothing] = rand(3) # also ok\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.DiscretizedDomain","page":"Usage","title":"Jutul.DiscretizedDomain","text":"DiscretizedDomain(domain, disc = nothing)\n\nA type for a discretized domain of some other domain or mesh. May contain one or more discretizations as-needed to write equations.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JutulDiscretization","page":"Usage","title":"Jutul.JutulDiscretization","text":"Abstract type for a Jutul discretization\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.setup_state","page":"Usage","title":"Jutul.setup_state","text":"setup_state(model::JutulModel, name1 = value1, name2 = value2)\n\nSet up a state for a given model with values for the primary variables defined in the model. Normally all primary variables must be initialized in this way.\n\nArguments\n\nname=value: The name of the primary variable together with the value(s) used to initialize the primary variable.\n\nA scalar (or short vector of the right size for VectorVariables) will be repeated over the entire domain, while a vector (or matrix for VectorVariables) with length (number of columns for VectorVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\nNote: You likely want to overload [setup_state!]@ref for a custom model instead of setup_state\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_parameters","page":"Usage","title":"Jutul.setup_parameters","text":"setup_parameters(model::JutulModel; name = value)\n\nSet up a parameter storage for a given model with values for the parameter defined in the model.\n\nArguments\n\nname=value: The name of the parameter together with the value(s) of the parameter.\n\nA scalar (or short vector of the right size for VectorVariables) will be repeated over the entire domain, while a vector (or matrix for VectorVariables) with length (number of columns for VectorVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_state_and_parameters","page":"Usage","title":"Jutul.setup_state_and_parameters","text":"state, prm = setup_state_and_parameters(model, init)\n\nSimultaneously set up state and parameters from a single init file (typically a Dict containing values that might either be initial values or parameters)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.setup_forces","page":"Usage","title":"Jutul.setup_forces","text":"setup_forces(model::JutulModel; force_name = force_value)\n\nSet up forces for a given model. Keyword arguments varies depending on what the model supports.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.simulate","page":"Usage","title":"Jutul.simulate","text":"simulate(state0, model, timesteps, parameters = setup_parameters(model))\nsimulate(state0, model, timesteps, info_level = 3)\nsimulate(state0, model, timesteps; <keyword arguments>)\n\nSimulate a set of timesteps with model for the given initial state0 and optionally specific parameters. Additional keyword arguments are passed onto simulator_config and simulate!. This interface is primarily for convenience, as all storage for the simulator is allocated upon use and discared upon return. If you want to perform multiple simulations with the same model it is advised to instead instantiate Simulator  and combine it with simulate!.\n\nArguments\n\nstate0::Dict: initial state, typically created using setup_state for the model in use.\nmodel::JutulModel: model that describes the discretized system to solve, for example SimulationModel or MultiModel.\ntimesteps: Vector of desired report steps. The simulator will perform time  integration until sum(timesteps). You can also provide a single step in  place of a vector. is reached, providing outputs at the end of each report  step. If a Inf value is provided as any of the time-steps, the simulator  will either perform an infinite step (if no max_timestep is provided) or the  simulator will perform timestepping forever until the termination criterion  is met. If you pass Inf and no termination criterion is provided, the  simulator will error.\nparameters=setup_parameters(model): Optional overrides the default parameters for the model.\nforces=nothing: Either nothing (for no forces), a single set of forces from setup_forces(model) or a Vector of such forces with equal length to timesteps.\nrestart=nothing: If an integer is provided, the simulation will attempt to restart from that step. Requires that output_path is provided here or in the config.\nconfig=simulator_config(model): Configuration object that holds many fine grained settings for output, linear solver, time-steps, outputs etc.\n\nAdditional arguments are passed onto simulator_config.\n\nSee also simulate!, Simulator, SimulationModel, simulator_config.\n\n\n\n\n\nsimulate(state0, sim::JutulSimulator, timesteps; parameters = nothing, kwarg...)\n\nSimulate a set of timesteps with simulator for the given initial state0 and optionally specific parameters.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.simulate!","page":"Usage","title":"Jutul.simulate!","text":"simulate!(sim::JutulSimulator, timesteps;\n    forces = nothing,\n    config = nothing,\n    initialize = true,\n    restart = nothing,\n    state0 = nothing,\n    parameters = nothing,\n    kwarg...\n)\n\nNon-allocating (or perhaps less allocating) version of simulate!.\n\nArguments\n\ninitialize=true: Perform internal updates as if this is the first time \n\nSee also simulate for additional supported input arguments.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.solve_timestep!","page":"Usage","title":"Jutul.solve_timestep!","text":"solve_timestep!(sim, dT, forces, max_its, config; <keyword arguments>)\n\nInternal function for solving a single time-step with fixed driving forces.\n\nArguments\n\nsim: Simulator instance.\ndT: time-step to be solved\nforces: Driving forces for the time-step\nmax_its: Maximum number of steps/Newton iterations.\nconfig: Configuration for solver (typically output from simulator_config).\n\nNote: This function is exported for fine-grained simulation workflows. The general simulate interface is both easier to use and performs additional validation.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.Simulator","page":"Usage","title":"Jutul.Simulator","text":"Simulator(model; <kwarg>)\n\nSet up a simulator object for a model that can be used by simulate!. To avoid manually instantiating the simulator, the non-mutating simulate interface can be used instead.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.simulator_config","page":"Usage","title":"Jutul.simulator_config","text":"simulator_config(sim; info_level = 3, linear_solver = GenericKrylov())\n\nSet up a simulator configuration object that can be passed onto simulate!.\n\nThere are many options available to configure a given simulator. The best way to get an overview of these possible configuration options is to instatiate the config without any arguments and inspecting the resulting table by calling simulator_config(sim) in the REPL.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.JutulConfig","page":"Usage","title":"Jutul.JutulConfig","text":"JutulConfig(name = nothing)\n\nA configuration object that acts like a Dict{Symbol,Any} but contains additional data to limit the valid keys and values to those added by add_option!\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.add_option!","page":"Usage","title":"Jutul.add_option!","text":"add_option!(opts::JutulConfig, :my_cool_option, 3, \"My option has this brief description\")\n\nAdd an option to existing JutulConfig structure. Additional currently undocumented keyword arguments can be used to restrict valid types and values.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Jutul.GenericKrylov","page":"Usage","title":"Jutul.GenericKrylov","text":"GenericKrylov(solver = :gmres; preconditioner = nothing; <kwarg>)\n\nSolver that wraps Krylov.jl with support for preconditioning.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.LUSolver","page":"Usage","title":"Jutul.LUSolver","text":"LUSolver(; reuse_memory = true, check = true, max_size = 50000)\n\nDirect solver that calls lu directly. Direct solvers are highly accurate, but are costly in terms of memory usage and execution speed for larger systems.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.AMGPreconditioner","page":"Usage","title":"Jutul.AMGPreconditioner","text":"AMG on CPU (Julia native)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.ILUZeroPreconditioner","page":"Usage","title":"Jutul.ILUZeroPreconditioner","text":"ILU(0) preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.JacobiPreconditioner","page":"Usage","title":"Jutul.JacobiPreconditioner","text":"Damped Jacobi preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.SPAI0Preconditioner","page":"Usage","title":"Jutul.SPAI0Preconditioner","text":"Sparse Approximate Inverse preconditioner of lowest order – SPAI(0)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.LUPreconditioner","page":"Usage","title":"Jutul.LUPreconditioner","text":"Full LU factorization as preconditioner (intended for smaller subsystems)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.GroupWisePreconditioner","page":"Usage","title":"Jutul.GroupWisePreconditioner","text":"Multi-model preconditioners\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.DefaultContext","page":"Usage","title":"Jutul.DefaultContext","text":"Default context\n\n\n\n\n\n","category":"type"},{"location":"usage/#Jutul.ParallelCSRContext","page":"Usage","title":"Jutul.ParallelCSRContext","text":"A context that uses a CSR sparse matrix format together with threads. Experimental.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Meshes-and-mesh-utilities","page":"Meshes and mesh utilities","title":"Meshes and mesh utilities","text":"","category":"section"},{"location":"mesh/#Mesh-types","page":"Meshes and mesh utilities","title":"Mesh types","text":"Jutul has two main internal mesh types: Cartesian meshes and unstructured meshes. The unstructured format is a general polyhedral mesh format, and a Cartesian mesh can easily be converted to an unstructured mesh. Coarsened meshes can be created by a fine scale mesh and a partition vector.","category":"section"},{"location":"mesh/#Plotting-functions","page":"Meshes and mesh utilities","title":"Plotting functions","text":"Plotting requires that a Makie backend is loaded (typically GLMakie or CairoMakie). The documentation uses CairoMakie to work on machines without OpenGL enabled, but if you want fast and interactive plots, GLMakie should be preferred.","category":"section"},{"location":"mesh/#Non-mutating","page":"Meshes and mesh utilities","title":"Non-mutating","text":"","category":"section"},{"location":"mesh/#Mutating","page":"Meshes and mesh utilities","title":"Mutating","text":"","category":"section"},{"location":"mesh/#Example:-Cartesian-meshes","page":"Meshes and mesh utilities","title":"Example: Cartesian meshes","text":"For example, we can make a small 2D mesh with given physical dimensions and convert it:\n\nusing Jutul\nnx = 10\nny = 5\ng2d_cart = CartesianMesh((nx, ny), (100.0, 50.0))\n\ng2d = UnstructuredMesh(g2d_cart)\n\nWe can then plot it, colorizing each cell by its enumeration:\n\nusing CairoMakie\nfig, ax, plt = plot_cell_data(g2d, 1:number_of_cells(g2d))\nplot_mesh_edges!(ax, g2d)\nfig\n\nIf we want to drill down a bit further, we can make a plot:\n\nWe can make a 3D mesh in the same manner:\n\nnz = 3\ng3d = UnstructuredMesh(CartesianMesh((nx, ny, nz), (100.0, 50.0, 30.0)))\n\nAnd plot it the same way:\n\nusing CairoMakie\nnc = number_of_cells(g3d)\nfig, ax, plt = plot_cell_data(g3d, 1:nc)\nplot_mesh_edges!(ax, g3d)\nfig\n\nWe can also plot only a subset of cells:\n\nusing CairoMakie\nfig, ax, plt = plot_cell_data(g3d, 1:nc, cells = 1:2:nc)\nfig","category":"section"},{"location":"mesh/#Mesh-API-functions","page":"Meshes and mesh utilities","title":"Mesh API functions","text":"","category":"section"},{"location":"mesh/#Queries","page":"Meshes and mesh utilities","title":"Queries","text":"","category":"section"},{"location":"mesh/#Manipulation","page":"Meshes and mesh utilities","title":"Manipulation","text":"","category":"section"},{"location":"mesh/#Example:-Mesh-manipulation","page":"Meshes and mesh utilities","title":"Example: Mesh manipulation","text":"We can quickly build new meshes by applying transformations to an already existing mesh. Let us create a Cartesian mesh and extract the cells that lie within a circle:\n\nusing Jutul, CairoMakie\ng = UnstructuredMesh(CartesianMesh((10, 10), (1.0, 1.0)))\ngeo = tpfv_geometry(g)\nkeep = Int[]\nfor c in 1:number_of_cells(g)\n    x, y = geo.cell_centroids[:, c]\n    if (x - 0.5)^2 + (y - 0.5)^2 < 0.25\n        push!(keep, c)\n    end\nend\nsubg = extract_submesh(g, keep)\nfig, ax, plt = plot_mesh(subg)\nplot_mesh_edges!(ax, g, color = :red)\nfig\n\nWe can turn this into a 3D mesh by extruding it, and then tweak the nodes:\n\ng3d = Jutul.extrude_mesh(subg, 20)\nfor node in eachindex(subg.node_points)\n    g3d.node_points[node] += 0.01*rand(3)\nend\nfig, ax, plt = plot_mesh(g3d)\nfig","category":"section"},{"location":"mesh/#Geometry","page":"Meshes and mesh utilities","title":"Geometry","text":"","category":"section"},{"location":"mesh/#Example:-Cell-intersection","page":"Meshes and mesh utilities","title":"Example: Cell intersection","text":"using CairoMakie, Jutul\n# 3D mesh\nG = CartesianMesh((4, 4, 5), (100.0, 100.0, 100.0))\ntrajectory = [\n    50.0 25.0 1;\n    55 35.0 25;\n    65.0 40.0 50.0;\n    70.0 70.0 90.0\n]\n\ncells = Jutul.find_enclosing_cells(G, trajectory)\n\n# Optional plotting, requires Makie:\nfig, ax, plt = Jutul.plot_mesh_edges(G)\nplot_mesh!(ax, G, cells = cells, alpha = 0.5, transparency = true)\nlines!(ax, trajectory, linewidth = 10)\nfig\n\n2D version:\n\nusing CairoMakie, Jutul\n# 2D mesh\nG = CartesianMesh((50, 50), (1.0, 2.0))\ntrajectory = [\n    0.1 0.1;\n    0.2 0.4;\n    0.3 1.2\n]\nfig, ax, plt = Jutul.plot_mesh_edges(G)\ncells = Jutul.find_enclosing_cells(G, trajectory)\n# Plotting, needs Makie\nfig, ax, plt = Jutul.plot_mesh_edges(G)\nplot_mesh!(ax, G, cells = cells, alpha = 0.5, transparency = true)\nlines!(ax, trajectory[:, 1], trajectory[:, 2], linewidth = 3)\nfig","category":"section"},{"location":"mesh/#Mesh-generation","page":"Meshes and mesh utilities","title":"Mesh generation","text":"","category":"section"},{"location":"mesh/#Gmsh-support","page":"Meshes and mesh utilities","title":"Gmsh support","text":"","category":"section"},{"location":"mesh/#Radial-mesh","page":"Meshes and mesh utilities","title":"Radial mesh","text":"using Jutul, CairoMakie\nimport Jutul.RadialMeshes: radial_mesh\nimport Jutul: plot_mesh_edges\nnangle = 10\nradii = [0.2, 0.5, 1.0]\nm = radial_mesh(nangle, radii; centerpoint = true)\nplot_mesh_edges(m)\n\nRadial meshes can still be indexed as Cartesian meshes:\n\nIJ = map(i -> cell_ijk(m, i), 1:number_of_cells(m))\n\nfig, ax, plt = plot_cell_data(m, map(first, IJ))\nfig\n\nfig, ax, plt = plot_cell_data(m, map(ijk -> ijk[2], IJ))\nfig\n\nWe can also plot the faces by using the nodes together with standard Makie plotting calls. We regenerate the mesh and make it contain a single cell in the middle before plotting it:\n\nm = radial_mesh(nangle, radii; centerpoint = false)\nncells = number_of_cells(m)\nfig, ax, plt = plot_cell_data(m, 1:ncells, alpha = 0.25)\nscatter!(ax, m.node_points)\nfor face in 1:number_of_faces(m)\n    n1, n2 = m.faces.faces_to_nodes[face]\n    pt1 = m.node_points[n1]\n    pt2 = m.node_points[n2]\n    lines!(ax, [pt1, pt2], color = :red)\nend\n\nfor bface in 1:number_of_boundary_faces(m)\n    n1, n2 = m.boundary_faces.faces_to_nodes[bface]\n    pt1 = m.node_points[n1]\n    pt2 = m.node_points[n2]\n    lines!(ax, [pt1, pt2], color = :blue)\nend\nfig\n\nWe can also zoom in on a single cell and plot the oriented normals:\n\nusing LinearAlgebra\ngeo = tpfv_geometry(m)\ncellno = 1\nfig, ax, plt = plot_mesh(m, cells = cellno)\nfor face in m.faces.cells_to_faces[cellno]\n    n1, n2 = m.faces.faces_to_nodes[face]\n    @info \"Interior edge $n1 to $n2\"\n    pt1 = m.node_points[n1]\n    pt2 = m.node_points[n2]\n    lines!(ax, [pt1, pt2], color = :red)\n    midpt = (pt1 + pt2) / 2\n    if m.faces.neighbors[face][1] == cellno\n        sgn = 1\n    else\n        sgn = -1\n    end\n    lines!(ax, [midpt, midpt + sgn*norm(pt2 - pt1, 2)*geo.normals[:, face]], color = :orange)\nend\nfor bface in m.boundary_faces.cells_to_faces[cellno]\n    n1, n2 = m.boundary_faces.faces_to_nodes[bface]\n    @info \"Exterior edge $n1 to $n2\"\n    pt1 = m.node_points[n1]\n    pt2 = m.node_points[n2]\n    lines!(ax, [pt1, pt2], color = :blue)\n    midpt = (pt1 + pt2) / 2\n    lines!(ax, [midpt, midpt + norm(pt2 - pt1, 2)*geo.boundary_normals[:, bface]], color = :green)\nend\nscatter!(ax, m.node_points)\nfig","category":"section"},{"location":"mesh/#Spiral-meshes","page":"Meshes and mesh utilities","title":"Spiral meshes","text":"using Jutul, CairoMakie\nimport Jutul.RadialMeshes: spiral_mesh\nn_angular_sections = 10\nnrotations = 4\nspacing = [0.0, 0.5, 1.0]\nrmesh = spiral_mesh(n_angular_sections, nrotations, spacing = spacing)\nnum_cells = number_of_cells(rmesh)\n\nfig, ax, plt = plot_cell_data(rmesh, 1:number_of_cells(rmesh))\nfig\n\nimport Jutul.RadialMeshes: spiral_mesh_tags\ntags = spiral_mesh_tags(rmesh, spacing)\nfig = Figure(size = (400, 1800))\nfor (figno, pp) in enumerate(pairs(tags))\n    k, val = pp\n    ax = Axis(fig[figno, 1], title = \"Spiral tag $k\")\n    plot_cell_data!(ax, rmesh, val)\nend\nfig","category":"section"},{"location":"mesh/#Jutul.JutulMesh","page":"Meshes and mesh utilities","title":"Jutul.JutulMesh","text":"A mesh is a type of domain that has been discretized. Abstract subtype.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.CartesianMesh","page":"Meshes and mesh utilities","title":"Jutul.CartesianMesh","text":"CartesianMesh(dims, [Δ, [origin]])\n\nCreate a Cartesian mesh with dimensions specified by the Tuple dims.\n\nArguments\n\ndims::Tuple: Number of grid cells in each direction. For example, (nx, ny) will give a 2D grids with nx cells in the x-direction.\nΔ::Tuple=Tuple(ones(length(dims))): Equal length to dims. First option: A\n\nTuple of scalars where each entry is the length of each cell in that direction. For example, specifying (Δx, Δy) for a uniform grid with each grid cell having area ofΔx*Δy. Second option: ATuple` of vectors where each entry contains the cell sizes in the direction.\n\norigin=zeros(length(dims)): The origin of the first corner in the grid.\n\nExamples\n\nGenerate a uniform 3D mesh that discretizes a domain of 2 by 3 by 5 units with 3 by 5 by 2 cells:\n\njulia> CartesianMesh((3, 5, 2), (2.0, 3.0, 5.0))\nCartesianMesh (3D) with 3x5x2=30 cells\n\nGenerate a non-uniform 2D mesh:\n\njulia> CartesianMesh((2, 3), ([1.0, 2.0], [0.1, 3.0, 2.5]))\nCartesianMesh (2D) with 2x3x1=6 cells\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.UnstructuredMesh","page":"Meshes and mesh utilities","title":"Jutul.UnstructuredMesh","text":"UnstructuredMesh(g::CartesianMesh)\n\nConvert CartesianMesh instance to unstructured grid. Note that the mesh must be 2D and 3D for a 1-to-1 conversion. 1D meshes are implicitly converted to 2D.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.CoarseMesh","page":"Meshes and mesh utilities","title":"Jutul.CoarseMesh","text":"CoarseMesh(G::JutulMesh, p)\n\nConstruct a coarse mesh from a given JutulMesh that can be converted to an UnstructuredMesh instance. The second argument p should be a partition Vector with one entry per cell in the original grid that assigns that cell to a coarse block. Should be one-indexed and the numbering should be sequential and contain at least one fine cell for each coarse index. This is tested by the function.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.MRSTWrapMesh","page":"Meshes and mesh utilities","title":"Jutul.MRSTWrapMesh","text":"MRSTWrapMesh(G, N = nothing)\n\nMesh that adapts an exported MRST mesh to the Jutul interface. G is assumed to be read directly from file using MAT.matread. The raw exported grid can be found under the data field.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.plot_mesh","page":"Meshes and mesh utilities","title":"Jutul.plot_mesh","text":"plot_mesh(mesh)\nplot_mesh(mesh;\n    cells = nothing,\n    faces = nothing,\n    boundaryfaces = nothing,\n    outer = false,\n    color = :lightblue,\n)\n\nPlot a mesh with uniform colors. Optionally, indices cells, faces or boundaryfaces can be passed to limit the plotting to a specific selection of entities.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_cell_data","page":"Meshes and mesh utilities","title":"Jutul.plot_cell_data","text":"plot_cell_data(mesh::JutulMesh, data::Vector; kwarg...)\nplot_cell_data(mesh, data;\n    cells = nothing,\n    faces = nothing,\n    boundaryfaces = nothing\n)\n\nPlot cell-wise values (as a vector) on the mesh. Optionally, indices cells, faces or boundaryfaces can be passed to limit the plotting to a specific selection of entities.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_mesh_edges","page":"Meshes and mesh utilities","title":"Jutul.plot_mesh_edges","text":"plot_mesh_edges(mesh; kwarg...)\n\nPlot the edges of all cells on the exterior of a mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_interactive","page":"Meshes and mesh utilities","title":"Jutul.plot_interactive","text":"plot_interactive(mesh, vector_of_dicts; kwarg...)\n\nLaunch an interactive plot of a mesh with the given vector_of_dicts (or just a dict). Each dict can have cell data either as vectors (one value per cell) or matrices (one column per cell).\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_mesh!","page":"Meshes and mesh utilities","title":"Jutul.plot_mesh!","text":"plot_mesh!(ax, mesh)\n\nMutating version of plot_mesh that plots into an existing Makie Axis instance.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_cell_data!","page":"Meshes and mesh utilities","title":"Jutul.plot_cell_data!","text":"plot_cell_data!(ax, mesh, data; kwarg...)\n\nMutating version of plot_cell_data that plots into an existing Makie Axis\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.plot_mesh_edges!","page":"Meshes and mesh utilities","title":"Jutul.plot_mesh_edges!","text":"plot_mesh_edges!(ax, mesh; kwarg...)\n\nPlot the edges of all cells on the exterior of a mesh into existing Makie Axis ax.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.number_of_cells","page":"Meshes and mesh utilities","title":"Jutul.number_of_cells","text":"number_of_cells(D::Union{DataDomain, DiscretizedDomain})\n\nGet the number of cells in a DataDomain or DiscretizedDomain.\n\n\n\n\n\nnumber_of_cells(g)::Integer\n\nGet the number of cells in a mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.number_of_faces","page":"Meshes and mesh utilities","title":"Jutul.number_of_faces","text":"number_of_faces(D::Union{DataDomain, DiscretizedDomain})\n\nGet the number of faces in a DataDomain or DiscretizedDomain.\n\n\n\n\n\nnumber_of_faces(g)::Integer\n\nGet the number of faces in a mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.number_of_boundary_faces","page":"Meshes and mesh utilities","title":"Jutul.number_of_boundary_faces","text":"number_of_boundary_faces(g)\n\nGet the number of boundary/exterior faces in a mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.extrude_mesh","page":"Meshes and mesh utilities","title":"Jutul.extrude_mesh","text":"extrude_mesh(m2d::UnstructuredMesh, nlayers)\nextrude_mesh(m2d::UnstructuredMesh, [1, 2, 5, 10])\n\nExtrude a 2D mesh into a 3D mesh by adding layers of cells in the z-direction. The number of layers can be specified as an integer or as an array of depths. The depths must be in increasing order.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.extract_submesh","page":"Meshes and mesh utilities","title":"Jutul.extract_submesh","text":"extract_submesh(g::UnstructuredMesh, cells)\n\nExtract a subgrid for a given mesh and a iterable of cells to keep.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.TwoPointFiniteVolumeGeometry","page":"Meshes and mesh utilities","title":"Jutul.TwoPointFiniteVolumeGeometry","text":"TwoPointFiniteVolumeGeometry(neighbors, areas, volumes, normals, cell_centers, face_centers)\n\nStore two-point geometry information for a given list of neighbors specified as a 2 by n matrix where n is the number of faces such that face i connectes cells N[1, i] and N[2, i].\n\nThe two-point finite-volume geometry contains the minimal set of geometry information required to compute standard finite-volume discretizations.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Jutul.tpfv_geometry","page":"Meshes and mesh utilities","title":"Jutul.tpfv_geometry","text":"tpfv_geometry(g)\n\nGenerate two-point finite-volume geometry for a given grid, if supported.\n\nSee also TwoPointFiniteVolumeGeometry.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.find_enclosing_cells","page":"Meshes and mesh utilities","title":"Jutul.find_enclosing_cells","text":"find_enclosing_cells(G, traj; geometry = tpfv_geometry(G), n = 25)\n\nFind the cell indices of cells in the mesh G that are intersected by a given trajectory traj. traj can be either a matrix with equal number of columns as dimensions in G (i.e. three columns for 3D) or a Vector of SVector instances with the same length.\n\nThe optional argument geometry is used to define the centroids and normals used in the calculations. You can precompute this if you need to perform many searches. The keyword argument n can be used to set the number of discretizations in each segment.\n\nuse_boundary is by default set to false. If set to true, the boundary faces of cells are treated more rigorously when picking exactly what cells are cut by a trajectory, but this requires that the boundary normals are oriented outwards, which is currently not the case for all meshes from downstream packages.\n\natol is the tolerance used when checking if points are inside the bounding box.\n\nlimit_box speeds up the search by limiting the search to the minimal bounding box that contains both the trajectory and the mesh. This can be turned off by passing false. There should be no difference in the cells tagged by changing this option.\n\ncells can be used to limit the search to a subset of cells in the mesh. By default all cells are used. If limit_box is true, the function searches among the cells in intersect(cells, cells inside bounding box).\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.cells_inside_bounding_box","page":"Meshes and mesh utilities","title":"Jutul.cells_inside_bounding_box","text":"cells_inside_bounding_box(G::UnstructuredMesh, low_bb, high_bb; algorithm = :box, atol = 0.01)\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.mesh_from_gmsh","page":"Meshes and mesh utilities","title":"Jutul.mesh_from_gmsh","text":"G = mesh_from_gmsh(pth)\nG = mesh_from_gmsh()\nG = mesh_from_gmsh(pth; verbose = true)\n\nParse a Gmsh file and return a Jutul UnstructuredMesh (in 3D only). Requires the Gmsh.jl package to be loaded. If no path is provided in pth it is assumed that you are managing the Gmsh state manually and it will use the current selected mesh inside Gmsh. Please note that Gmsh is GPL licensed unless you have obtained another type of license from the authors.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.RadialMeshes.spiral_mesh","page":"Meshes and mesh utilities","title":"Jutul.RadialMeshes.spiral_mesh","text":"mesh = spiral_mesh(10, 3, spacing = [0.0, 0.5, 1.0])\n\nSpiral mesh generator. Generates a spiral mesh in 2D with an optional \"spacing\" subdiscretization between each segment.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Jutul.RadialMeshes.spiral_mesh_tags","page":"Meshes and mesh utilities","title":"Jutul.RadialMeshes.spiral_mesh_tags","text":"spiral_mesh_tags(rmesh, spacing = missing)\n\nGet the tags for a spiral mesh. If spacing is provided, it will also return the spacing and winding tags.\n\n\n\n\n\n","category":"function"},{"location":"units/#Units","page":"Units","title":"Units","text":"Jutul assumes that all physical quantities are represented in SI units internally (or another consistent system). To facilitate conversion between different unit systems, Jutul provides utility functions to convert values to and from SI units.\n\nThere are also Julia packages like Unitful.jl and DynamicQuantities.jl that can be used to embed units in types, but these are not directly integrated with Jutul at this time. Performing calculations with your unit system of choice before striping units and passing values in SI to Jutul is the recommended approach.","category":"section"},{"location":"units/#Jutul.convert_to_si","page":"Units","title":"Jutul.convert_to_si","text":"convert_to_si(value, unit_name::String)\n\nConvert value to SI representation from value in the unit given by unit_symbol.\n\nAvailable units\n\nYou can get a list of all available units via Jutul.available_units(). The values in Jutul itself are:\n\nA, BTU, British thermal unit, Da, F, Gal, J, K, Kelvin, L, N, Pa, R, Rankine, Standard barrel, W, amp, ampere, atm, atmosphere, bar, btu, dalton, darcy, day, dyn, dyne, farad, feet, ft, g, gal, gallon_us, gram, hour, in, inch, joule, kelvin, kg, kilogram, l, lb, lbf, liter, litre, m, meter, minute, mol, newton, pascal, poise, pound, pound-force, psi, rankine, s, second, site, stb, tonne, usgal, watt, year.\n\nIn addition units can be prefixed with standard SI prefixes. Available prefixes are:\n\nquetta, ronna, yotta, zetta, exa, peta, tera, giga, mega, kilo, hecto, deca, deci, centi, milli, micro, nano, pico, femto, atto, zepto, yocto, ronto, quecto.\n\nThis utility can also handle composite units, e.g. \"kilometer/hour\" or \"meter/second^2\". Note that relative temperature units (Celsius and Fahrenheit) must be converted to absolute units (Kelvin or Rankine) before being used in composite units.\n\nExamples\n\njulia> convert_to_si(1.0, :hour) # Get 1 hour represented as seconds\n3600.0\njulia> convert_to_si(5.0, \"kilometer/hour\") # Get 5 kilometers per hour represented as seconds\n1.3888888888888888\njulia> convert_to_si(1.0, \"milligram\") # Get 1 milligram represented as kilograms\n1.0e-6\n\n\n\n\n\n","category":"function"},{"location":"units/#Jutul.convert_from_si","page":"Units","title":"Jutul.convert_from_si","text":"convert_from_si(value, unit_name::Union{Symbol, String})\n\nConvert value from SI representation to the unit in unit_symbol.\n\nExamples\n\njulia> convert_from_si(3600.0, :hour) # Get 3600 s represented as hours\n1.0\n\n\n\n\n\n","category":"function"},{"location":"units/#Jutul.si_unit","page":"Units","title":"Jutul.si_unit","text":"si_unit(u::Union{String, Symbol})\n\nGet the multiplicative SI unit conversion factor for a single unit. The return value is given so that x*si_unit(:name) will convert x to the SI representation of the unit with the given name. Composite units are also supported via strings, e.g. si_unit(\"feet^3/second\").\n\nExamples\n\njulia> si_unit(:day) # Get days represented as seconds\n86400.0\n\n\n\n\n\n","category":"function"},{"location":"units/#Jutul.@si_str","page":"Units","title":"Jutul.@si_str","text":"si\"kg/meter\"\n\nA string macro to convert unit strings to SI conversion factors. Convenience function for si_unit.\n\nExamples\n\njulia> si\"day\" # Get days represented as seconds\n86400.0\njulia> si\"kilometer/hour\" # Get kilometers per hour represented as seconds\n0.2777777777777778\njulia> si\"3.14*kilometer/hour\" # Get 3.14 kilometers per hour represented as seconds\n0.8722222222222222\njulia> si\"100gram + 0.1kilogram\" # Get 100 grams + 0.1 kilogram represented as kilograms\n0.2\n\n\n\n\n\n","category":"macro"},{"location":"#Jutul-documentation","page":"Home","title":"Jutul documentation","text":"","category":"section"},{"location":"#About","page":"Home","title":"About","text":"Jutul is an experimental Julia framework for multiphysics processes based on implicit finite-volume methods with automatic differentiation. The main public demonstrator is JutulDarcy.jl - a fully differentiable porous media simulator with excellent performance.","category":"section"},{"location":"#An-example","page":"Home","title":"An example","text":"Jutul is primarily intended to build applications. The base library includes a few \"hello world\"-type PDE solvers that are used for testing. One of these is the standard 2D heat equation on residual form:\n\nfracpartial Tpartial t - fracpartial^2 Tpartial x^2 - fracpartial^2 Tpartial y^2 = 0\n\nThe test solver uses a structured grid and a central difference scheme with periodic boundary conditions to solve this system. You can view the complete source code for this solver here.","category":"section"},{"location":"#Simulation-loop","page":"Home","title":"Simulation loop","text":"We demonstrate how to set up the simulation loop. This essentially boils down to three things: Setting up a grid/model, setting initial condition and picking time-steps where the solver should report output:\n\nusing Jutul\nsys = SimpleHeatSystem()\n# Create a 100x100 grid\nnx = ny = 100\nL = 100.0\nH = 100.0\ng = CartesianMesh((nx, ny), (L, H))\n# Create a data domain with geometry information\nD = DataDomain(g)\n# Set up a model with the grid and system\nmodel = SimulationModel(D, sys)\n# Initial condition is random values\nnc = number_of_cells(g)\nT0 = zeros(nc)\nx = D[:cell_centroids][1, :]\ny = D[:cell_centroids][2, :]\n# Create initial peak of heat to diffuse out.\nfor i in 1:nc\n    if (x[i] > 0.25*L) & (x[i] < 0.75*L) & (y[i] > 0.25*H) & (y[i] < 0.75*H)\n        T0[i] = 100.0\n    end\nend\nstate0 = setup_state(model, Dict(:T=>T0))\nsim = Simulator(model, state0 = state0)\ndt = fill(1.0, 100)\nstates, = simulate(sim, dt, info_level = 1);","category":"section"},{"location":"#Visualizing-the-results","page":"Home","title":"Visualizing the results","text":"If using Julia 1.9 or later, visualization is provided if a version of Makie is included. In the documentation we use CairoMakie as it can produce plots on servers without rendering capabilities, such as the one where the Jutul continious integration is running:\n\nusing CairoMakie\n\nIf you are running this locally and want interactive plots you can instead use the GLMakie backend.\n\nusing GLMakie\nGLMakie.activate!()\n\nWe plot the initial conditions:\n\nfig, ax = plot_cell_data(g, state0[:T])\nfig\n\nWe can then plot the final state, observing significant diffusion from the sharp initial state.\n\nfig, ax = plot_cell_data(g, states[end][:T])\nfig\n\nThere is also interactive plotting that allows you to step through each time-step. This is most relevant when using GLMakie to plot, otherwise the figure will be static.\n\nplot_interactive(g, [state0; states])","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"internals/#Internal-docstrings","page":"Internals","title":"Internal docstrings","text":"These functions are mostly relevant for implementing simulators in the Jutul framework.","category":"section"},{"location":"internals/#Entities-and-variables","page":"Internals","title":"Entities and variables","text":"","category":"section"},{"location":"internals/#Variables","page":"Internals","title":"Variables","text":"Variable types:\n\nVariables API:\n\nUpdating variables","category":"section"},{"location":"internals/#Entities","page":"Internals","title":"Entities","text":"Entities API","category":"section"},{"location":"internals/#Equations","page":"Internals","title":"Equations","text":"Equations API","category":"section"},{"location":"internals/#Automatic-differentiation","page":"Internals","title":"Automatic differentiation","text":"","category":"section"},{"location":"internals/#Matrix","page":"Internals","title":"Matrix","text":"","category":"section"},{"location":"internals/#Various","page":"Internals","title":"Various","text":"","category":"section"},{"location":"internals/#Jutul.JutulVariables","page":"Internals","title":"Jutul.JutulVariables","text":"Abstract type for all variables in Jutul.\n\nA variable is associated with a JutulEntity through the associated_entity function. A variable is local to that entity, and cannot depend on other entities. Variables are used by models to define:\n\nprimary variables: Sometimes referred to as degrees of freedom, primary unknowns or solution variables\nparameters: Static quantities that impact the solution\nsecondary variables: Can be computed from a combination of other primary and secondary variables and parameters.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.ScalarVariable","page":"Internals","title":"Jutul.ScalarVariable","text":"Abstract type for scalar variables (one entry per entity, e.g. pressure or temperature in each cell of a model)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.VectorVariables","page":"Internals","title":"Jutul.VectorVariables","text":"Abstract type for vector variables (more than one entry per entity, for example saturations or displacements)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.degrees_of_freedom_per_entity","page":"Internals","title":"Jutul.degrees_of_freedom_per_entity","text":"Number of independent primary variables / degrees of freedom per computational entity.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.values_per_entity","page":"Internals","title":"Jutul.values_per_entity","text":"Number of values held by a primary variable. Normally this is equal to the number of degrees of freedom, but some special primary variables are most conveniently defined by having N values and N-1 independent variables.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.maximum_value","page":"Internals","title":"Jutul.maximum_value","text":"Upper (inclusive) limit for variable.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.minimum_value","page":"Internals","title":"Jutul.minimum_value","text":"Lower (inclusive) limit for variable.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.variable_scale","page":"Internals","title":"Jutul.variable_scale","text":"Define a \"typical\" numerical value for a variable to scale the linear system entries.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.absolute_increment_limit","page":"Internals","title":"Jutul.absolute_increment_limit","text":"Absolute allowable change for variable during a nonlinear update.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.relative_increment_limit","page":"Internals","title":"Jutul.relative_increment_limit","text":"Relative allowable change for variable during a nonlinear update. A variable with value |x| and relative limit 0.2 cannot change more than |x|*0.2.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.associated_entity","page":"Internals","title":"Jutul.associated_entity","text":"Return the domain entity the equation is associated with\n\n\n\n\n\nThe entity a variable is associated with, and can hold partial derivatives with respect to.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.@jutul_secondary","page":"Internals","title":"Jutul.@jutul_secondary","text":"Designate the function as updating a secondary variable.\n\nA generic evaluator is then defined, together with a function for getting the dependencies of that function upon the state. This is most easily documented with an example. If we define the following function annotated with the macro when updating the array containing the values of MyVarType realized for some model:\n\n@jutul_secondary function some_fn!(target, var::MyVarType, model, a, b, c, ix)\n    for i in ix\n        target[i] = a[i] + b[i] / c[i]\n    end\nend\n\nThe purpose of the macro is to translate this into two functions. The first defines for the dependencies of the function with respect to the fields of the state (primary variables, secondary variables and parameters):\n\nfunction get_dependencies(var::MyVarType, model)\n   return (:a, :b, :c)\nend\n\nThe second function defines a generic version that takes in state, and automatically expands the set of dependencies into getfield calls.\n\nfunction update_secondary_variable!(array_target, var::MyVarType, model, state, ix)\n    some_fn!(array_target, var, model, state.a, state.b, state.c, ix)\nend\n\nNote that the input names of arguments 4 to end-1 matter, as these will be fetched from state, exactly as written.\n\n\n\n\n\n","category":"macro"},{"location":"internals/#Jutul.get_dependencies","page":"Internals","title":"Jutul.get_dependencies","text":"Get dependencies of variable when viewed as a secondary variable. Normally autogenerated with @jutul_secondary\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.JutulEntity","page":"Internals","title":"Jutul.JutulEntity","text":"Super-type for all entities where JutulVariables can be defined.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.Cells","page":"Internals","title":"Jutul.Cells","text":"Entity for Cells (closed volumes with averaged properties for a finite-volume solver)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.Faces","page":"Internals","title":"Jutul.Faces","text":"Entity for Faces (intersection between pairs of Cells)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.Nodes","page":"Internals","title":"Jutul.Nodes","text":"Entity for Nodes (intersection between multiple Faces)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.number_of_partials_per_entity","page":"Internals","title":"Jutul.number_of_partials_per_entity","text":"number_of_partials_per_entity(model::SimulationModel, entity::JutulEntity)\n\nGet the number of local partial derivatives per entity in a model for a given JutulEntity. This is the sum of degrees_of_freedom_per_entity for all primary variables defined on entity.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.number_of_entities","page":"Internals","title":"Jutul.number_of_entities","text":"Get the number of entities (e.g. the number of cells) that the equation is defined on.\n\n\n\n\n\nGet number of entities a cache is defined on.\n\n\n\n\n\nNumber of entities for vector stored in state (just the number of elements)\n\n\n\n\n\nNumber of entities for matrix stored in state (convention is number of columns)\n\n\n\n\n\nNumber of entities (e.g. Cells, Faces) a variable is defined on. By default, each primary variable exists on all cells of a discretized domain\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.JutulEquation","page":"Internals","title":"Jutul.JutulEquation","text":"Abstract type for all residual equations\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.number_of_equations","page":"Internals","title":"Jutul.number_of_equations","text":"Get the total number of equations on the domain of model.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.number_of_equations_per_entity","page":"Internals","title":"Jutul.number_of_equations_per_entity","text":"n = number_of_equations_per_entity(model::JutulModel, eq::JutulEquation)\n\nGet the number of equations per entity. For example, mass balance of two components will have two equations per grid cell (= entity)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.value","page":"Internals","title":"Jutul.value","text":"Take value of AD.\n\n\n\n\n\nvalue(d::Dict)\n\nCall value on all elements of some Dict.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.as_value","page":"Internals","title":"Jutul.as_value","text":"Create a mapped array that produces only the values when indexed.\n\nOnly useful for AD arrays, otherwise it does nothing.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.local_ad","page":"Internals","title":"Jutul.local_ad","text":"local_ad(state::T, index::I, ad_tag::∂T) where {T, I<:Integer, ∂T}\n\nCreate localad for state for index I of AD tag of type adtag\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.JutulAutoDiffCache","page":"Internals","title":"Jutul.JutulAutoDiffCache","text":"An AutoDiffCache is a type that holds both a set of AD values and a map into some global Jacobian.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.CompactAutoDiffCache","page":"Internals","title":"Jutul.CompactAutoDiffCache","text":"Cache that holds an AD vector/matrix together with their positions.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.allocate_array_ad","page":"Internals","title":"Jutul.allocate_array_ad","text":"allocate_array_ad(n[, m]; <keyword arguments>)\n\nAllocate vector or matrix as AD with optionally provided context and a specified non-zero on the diagonal.\n\nArguments\n\nn::Integer: number of entries in vector, or number of rows if m is given.\nm::Integer: number of rows (optional)\n\nKeyword arguments\n\nnpartials = 1: Number of partials derivatives to allocate for each element\ndiag_pos = nothing: Indices of where to put entities on the diagonal (if any)\n\nOther keyword arguments are passed onto get_ad_entity_scalar.\n\nExamples:\n\nAllocate a vector with a single partial:\n\njulia> allocate_array_ad(2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 1}}:\n Dual{nothing}(0.0,0.0)\n Dual{nothing}(0.0,0.0)\n\nAllocate a vector with two partials, and set the first to one:\n\njulia> allocate_array_ad(2, diag_pos = 1, npartials = 2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,1.0,0.0)\n\nSet up a matrix with two partials, where the first column has partials [1, 0] and the second [0, 1]:\n\njulia> allocate_array_ad(2, 2, diag_pos = [1, 2], npartials = 2)\n2×2 Matrix{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)  Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,0.0,1.0)  Dual{nothing}(0.0,0.0,1.0)\n\n\n\n\n\nallocate_array_ad(v::AbstractVector, ...)\n\nConvert vector to AD vector.\n\n\n\n\n\nallocate_array_ad(v::AbstractMatrix, ...)\n\nConvert matrix to AD matrix.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.get_ad_entity_scalar","page":"Internals","title":"Jutul.get_ad_entity_scalar","text":"get_ad_entity_scalar(v::Real, npartials, diag_pos = nothing; <keyword_arguments>)\n\nGet scalar with partial derivatives as AD instance.\n\nArguments\n\nv::Real: Value of AD variable.\nnpartials: Number of partial derivatives each AD instance holds.\ndiag_pos = nothing: Position(s) of where to set 1 as the partial derivative instead of zero.\n\nKeyword arguments\n\ntag = nothing: Tag for AD instance. Two AD values of the different tag cannot interoperate to avoid perturbation confusion (see ForwardDiff documentation).\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.get_entries","page":"Internals","title":"Jutul.get_entries","text":"Get the entries of the main autodiff cache for an equation.\n\nNote: This only gets the .equation field's entries.\n\n\n\n\n\nGet entries of autodiff cache. Entries are AD vectors that hold values and derivatives.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.JutulMatrixLayout","page":"Internals","title":"Jutul.JutulMatrixLayout","text":"Abstract type for matrix layouts. A layout determines how primary variables and equations are ordered in a sparse matrix representation. Note that this is different from the matrix format itself as it concerns the ordering itself: For example, if all equations for a single cell come in sequence, or if a single equation is given for all entities before the next equation is written.\n\nDifferent layouts does not change the solution of the system, but different linear solvers support different layouts.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.EntityMajorLayout","page":"Internals","title":"Jutul.EntityMajorLayout","text":"Equations are grouped by entity, listing all equations and derivatives for entity 1 before proceeding to entity 2 etc.\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E2/∂S)₁, (∂E1/∂p)₂, (∂E2/∂S)₂\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.EquationMajorLayout","page":"Internals","title":"Jutul.EquationMajorLayout","text":"Equations are stored sequentially in rows, derivatives of same type in columns:\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E1/∂p)₂, (∂E2/∂S)₁, (∂E2/∂S)₂\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.BlockMajorLayout","page":"Internals","title":"Jutul.BlockMajorLayout","text":"Same as EntityMajorLayout, but the system is a sparse matrix where each entry is a small dense matrix.\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give a diagonal of length 2: [(∂E1/∂p)₁ (∂E1/∂S)₁ ; (∂E2/∂p)₁ (∂E2/∂S)₁] [(∂E1/∂p)₂ (∂E1/∂S)₂ ; (∂E2/∂p)₂ (∂E2/∂S)₂]\n\n\n\n\n\n","category":"type"},{"location":"internals/#Jutul.convergence_criterion","page":"Internals","title":"Jutul.convergence_criterion","text":"convergence_criterion(model, storage, eq, eq_s, r; dt = 1)\n\nGet the convergence criterion values for a given equation. Can be checked against the corresponding tolerances.\n\nArguments\n\nmodel: model that generated the current equation.\nstorage: global simulator storage.\neq::JutulEquation: equation implementation currently being checked\neq_s: storage for eq where values are contained.\nr: the local residual part corresponding to this model, as a matrix with column index equaling entity index\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.partition","page":"Internals","title":"Jutul.partition","text":"partition(N::AbstractMatrix, num_coarse, weights = ones(size(N, 2)); partitioner = MetisPartitioner(), groups = nothing, n = maximum(N), group_by_weights = false, buffer_group = true)\n\nPartition based on neighborship (with optional groups kept contigious after partitioning)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Jutul.load_balanced_endpoint","page":"Internals","title":"Jutul.load_balanced_endpoint","text":"load_balanced_endpoint(block_index, nvals, nblocks)\n\nEndpoint for interval block_index that subdivides nvals into nblocks in a load balanced manner. This is done by adding one element to the first set of blocks whenever possible.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"\n\n<!– @autodocs  Modules = [Jutul] –>","category":"section"}]
}
